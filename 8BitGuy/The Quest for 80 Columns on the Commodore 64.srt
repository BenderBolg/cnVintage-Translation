1
00:00:11,030 --> 00:00:13,290
1983年

2
00:00:13,290 --> 00:00:19,180
在当时 商用电脑和家用电脑之间有条明确的分界线

3
00:00:19,200 --> 00:00:23,740
而众多区别中的其中一个就是屏幕能显示文字的列数

4
00:00:24,500 --> 00:00:29,020
比如说VIC-20只能显示22列文字

5
00:00:29,780 --> 00:00:38,220
ZX81或者Timex Sinclair 1000都能显示32列 Tandy Color也是32列

6
00:00:38,760 --> 00:00:41,620
TI99/4a能显示40列

7
00:00:41,620 --> 00:00:48,740
尽管AppleII最初是40列 但是这个时间节点上80列扩展卡已经很流行了

8
00:00:49,060 --> 00:00:53,020
大部分CP/M机器 比如Kaypro使用的就是80列

9
00:00:53,020 --> 00:00:57,320
即使是Osborn那个5英寸小屏幕上都能显示52列

10
00:00:57,480 --> 00:01:02,140
当然啦 IBM PC从最初开始就是80列

11
00:01:02,840 --> 00:01:07,500
但是至今销量最高的电脑Commodore 64呢？

12
00:01:08,100 --> 00:01:10,580
默认情况下这是一台40列的机器

13
00:01:10,580 --> 00:01:15,740
但是本集我将介绍4种能让它显示80列的方法

14
00:01:15,740 --> 00:01:17,780
以及每种方法的优缺点

15
00:01:18,440 --> 00:01:23,320
第一种 也是最常用的方法就是用软件

16
00:01:23,880 --> 00:01:29,880
这也就需要把C64切换到图形模式 然后使用软件渲染的80列文字

17
00:01:30,060 --> 00:01:35,520
一般C64上的字符是8像素宽

18
00:01:35,860 --> 00:01:38,880
为了用内置的视频芯片产生80列

19
00:01:39,020 --> 00:01:43,500
就得全部减半 使用4像素宽的字体

20
00:01:43,500 --> 00:01:45,710
不算太差 是不是

21
00:01:45,710 --> 00:01:48,820
然而这个是模拟器上的效果

22
00:01:48,820 --> 00:01:51,420
而不是真机上的效果

23
00:01:51,720 --> 00:01:56,939
大部分人都在使用电视作为显示器 来看看效果吧……

24
00:01:57,840 --> 00:01:59,760
很难看清楚

25
00:01:59,770 --> 00:02:03,200
而且这个电视其实是已经比当时大部分的电视都要清楚了

26
00:02:03,200 --> 00:02:06,720
所以看不清楚是这个方法最大的缺点

27
00:02:07,140 --> 00:02:11,880
其它缺点包括需要使用至少8KB的内存用来做图形缓冲

28
00:02:11,880 --> 00:02:14,060
再加上一些它本身代码需要占用的内存

29
00:02:14,580 --> 00:02:19,640
所以对于一台只有64K内存的机器来说 也就是要花掉大约15%的内存

30
00:02:19,640 --> 00:02:21,600
来实现80列的显示

31
00:02:22,000 --> 00:02:23,620
另外一个问题是性能

32
00:02:23,900 --> 00:02:29,100
软件不能再直接更新显存了

33
00:02:29,100 --> 00:02:33,360
所有操作都要经过80列软件中转

34
00:02:33,360 --> 00:02:37,080
其次 因为使用的是图形模式

35
00:02:37,080 --> 00:02:39,500
所以说数据量大了很多

36
00:02:40,080 --> 00:02:43,240
以及本身在图形模式绘制文字的开销就不小

37
00:02:43,240 --> 00:02:47,540
所以可以明显发现屏幕卷动时候的速度下降

38
00:02:47,900 --> 00:02:53,300
所以说 因为缺少一个真正的80列模式 C64是很难成为一台商用机器了

39
00:02:53,680 --> 00:02:57,800
所以说C64上市没多久就出现了这个产品

40
00:02:57,810 --> 00:03:00,540
DATA 20 VIDEOPAK 80

41
00:03:00,540 --> 00:03:03,380
直接插入C64的卡带口

42
00:03:04,200 --> 00:03:06,490
在背后有3个接口

43
00:03:06,490 --> 00:03:10,880
一个是连接机器原本音视频输出的接口

44
00:03:10,880 --> 00:03:12,299
这就是通过它中转一下输出

45
00:03:12,880 --> 00:03:16,780
另外一个是用来连接正常显示器的接口

46
00:03:16,780 --> 00:03:19,640
第三个RCA接口是音频输出

47
00:03:19,640 --> 00:03:25,680
但是我就没搞明白这个接口的意义是什么 和另外一个接口的输出是完全一样的

48
00:03:25,680 --> 00:03:30,600
如果拆开看看就会发现一颗6845 CRT控制器

49
00:03:30,600 --> 00:03:33,480
也就是和Commodore PET系列里面用的是一样的

50
00:03:34,680 --> 00:03:40,520
而且其实和IBM CGA的控制芯片也是一样的

51
00:03:40,520 --> 00:03:43,960
只是少了那些产生彩色图像需要的外部电路

52
00:03:44,240 --> 00:03:46,980
所以这个只能产生黑白的文字

53
00:03:48,400 --> 00:03:54,260
第一件注意到的事情就是图像质量有了明显的劣化

54
00:03:54,580 --> 00:03:58,700
作为对比 这是正常的图像 这是经过卡带的图像

55
00:03:58,960 --> 00:04:06,380
所以就是 在正常情况下 它会直接转发(pass through)C64 VIC-2芯片输出的图像到显示器上

56
00:04:06,580 --> 00:04:10,140
所以你并不会损失任何彩色或者图形的机能

57
00:04:10,600 --> 00:04:16,220
但是如果你要激活这张卡带 就得输入SYS 36864

58
00:04:16,460 --> 00:04:18,700
这样就会启用40行模式

59
00:04:18,780 --> 00:04:23,190
不确定这个模式有什么用 而且这个模式也没有什么明显的优势

60
00:04:23,190 --> 00:04:25,520
而且是完全黑白的

61
00:04:25,520 --> 00:04:30,080
然而我要先展示几个和正常40行模式的区别

62
00:04:30,360 --> 00:04:33,720
首先第一点 字体和正常的Commodore字体完全不一样

63
00:04:34,680 --> 00:04:37,960
而且SHIFT+Commodore键也不能用了

64
00:04:38,900 --> 00:04:44,680
如果你熟悉Commodore机器的话 这个快捷键从PET一直沿用到了128 （然而PET并不支持这个）

65
00:04:44,680 --> 00:04:51,040
可以用来切换正常字体和全大写字体

66
00:04:51,320 --> 00:04:58,420
然而你可以按Shift+F1切换到小写 然后按F1回到大写模式

67
00:04:58,940 --> 00:05:03,440
而且还可以使用F5和F7在40列和80列模式间切换

68
00:05:03,440 --> 00:05:06,460
效果就和预想的差不多

69
00:05:08,360 --> 00:05:14,220
然而 虽然要比软件渲染模式清晰一点

70
00:05:14,220 --> 00:05:16,810
但是在电视上还是难以阅读

71
00:05:16,810 --> 00:05:20,680
在这种情况下 模糊其实是彩色电视造成的

72
00:05:21,140 --> 00:05:25,680
你看 其实复合视频信号是非常锐利清晰的

73
00:05:25,680 --> 00:05:27,360
只要是黑白的

74
00:05:27,360 --> 00:05:32,240
如果传输色彩 信号质量就会严重劣化 （colorburst：怪我咯）

75
00:05:32,259 --> 00:05:36,770
这个电视的情况就是 这是一台彩色电视 即使输入信号是黑白的

76
00:05:36,770 --> 00:05:38,190
它尝试解码的仍然是彩色信号

77
00:05:38,190 --> 00:05:41,940
电路是这么设计的 他就不可能产生锐利的图像

78
00:05:42,350 --> 00:05:46,880
如果你想的话 RGB信号 比如说CGA啊

79
00:05:46,880 --> 00:05:48,700
Amiga啊 甚至VGA啊

80
00:05:48,840 --> 00:05:54,580
其实也就是三条独立的单色信号 分别对应红绿蓝

81
00:05:54,580 --> 00:05:59,280
这样想的话单色的黑白图像就没道理比不上那些RGB信号了

82
00:05:59,280 --> 00:06:00,820
除了没有颜色

83
00:06:01,300 --> 00:06:03,860
于是连上这个老的Apple单色显示器

84
00:06:03,860 --> 00:06:09,200
这个显示器是为Apple II系统设计的 显示80列文字的效果非常好

85
00:06:11,040 --> 00:06:11,580
哇..

86
00:06:11,580 --> 00:06:13,979
可以看见图像非常清晰锐利

87
00:06:13,979 --> 00:06:16,349
80列文字可读性非常好

88
00:06:16,349 --> 00:06:21,050
我甚至把它接到了这个5英寸黑白电视上 而且画面非非常锐利

89
00:06:21,050 --> 00:06:25,680
经管我这双41岁的老眼已经很难看清这些小字母了

90
00:06:25,680 --> 00:06:28,640
另外一个选项是Commodore 1084显示器

91
00:06:28,640 --> 00:06:34,720
它有各种各样的输入接口 包括RGB 复合视频 S端子 和 黑白输入

92
00:06:34,720 --> 00:06:38,700
因为是为更高分辨率设计的 所以效果也非常好

93
00:06:43,240 --> 00:06:46,040
所以如果你需要80列的话

94
00:06:46,040 --> 00:06:47,960
首先需要一台可以支持它的显示器

95
00:06:47,960 --> 00:06:50,080
而且如果要用复合视频信号的话

96
00:06:50,080 --> 00:06:52,160
那么你大概需要一台单色显示器

97
00:06:52,170 --> 00:06:56,139
然而这类显示器其实在80年代还是很常见的

98
00:06:56,140 --> 00:06:59,260
特别主要是用于商务和学校

99
00:07:00,240 --> 00:07:04,140
所以我想讲一讲这类卡带的一大缺点

100
00:07:04,380 --> 00:07:07,120
就是几乎没有软件能够支持它

101
00:07:10,520 --> 00:07:14,320
我找到了个表格软件 虽然我弄不清楚要怎么用

102
00:07:14,580 --> 00:07:16,660
还有一个字处理软件

103
00:07:17,280 --> 00:07:20,800
我觉得两个软件应该都是这个设备的公司做的

104
00:07:20,800 --> 00:07:21,800
这样比较合理

105
00:07:23,380 --> 00:07:25,510
另外一个问题就是性能

106
00:07:25,510 --> 00:07:27,620
注意到写一个BASIC程序

107
00:07:27,620 --> 00:07:31,100
滚动屏幕的时候看起来就很慢

108
00:07:31,460 --> 00:07:35,350
这是由于CPU和视频芯片的通信方式造成的

109
00:07:35,350 --> 00:07:39,879
你看正常情况下C64的主芯片和视频芯片共享主内存

110
00:07:39,880 --> 00:07:43,120
所以CPU可以直接修改屏幕缓冲区的信息

111
00:07:43,120 --> 00:07:45,680
视频芯片就直接把新的数据刷上去了

112
00:07:45,690 --> 00:07:47,620
这个方法速度就很快

113
00:07:47,620 --> 00:07:49,979
这个设备有自己的屏幕内存

114
00:07:49,980 --> 00:07:55,380
也就是CPU必须要向设备发送指令来在屏幕上显示字符

115
00:07:55,380 --> 00:07:58,580
这就严重降低了效率

116
00:08:00,340 --> 00:08:02,759
现在我要再给你们看另外一个类似的设备

117
00:08:02,759 --> 00:08:05,610
由Batteries Included公司制造的BI-80

118
00:08:05,610 --> 00:08:10,200
概念类似 一个RCA输入 一个RCA输出

119
00:08:10,340 --> 00:08:14,920
如果拆开看一看的话 会发现主控是6545控制器

120
00:08:15,060 --> 00:08:18,720
也是基本和之前展示的是一样的

121
00:08:18,720 --> 00:08:22,060
然而这个的实现思路就很不一样了

122
00:08:23,360 --> 00:08:29,460
第一件事情就是 干扰小了很多

123
00:08:29,480 --> 00:08:35,040
所以对比下两个设备的情况 我觉得差距很明显了吧

124
00:08:35,240 --> 00:08:39,680
另外一件事情就是 BASIC少了8K的可用内存

125
00:08:39,980 --> 00:08:43,220
切换到80列模式

126
00:08:43,220 --> 00:08:46,710
这个需要另外一个命令 SYS 33000

127
00:08:46,710 --> 00:08:52,280
也和预想一样 在电视上是看不清了 所以还是开显示器

128
00:08:53,520 --> 00:08:58,140
随后注意到 这个使用的是标准的C64字体

129
00:08:58,140 --> 00:09:02,660
另外SHIFT+Commodore按键也是可以正常工作的

130
00:09:02,660 --> 00:09:05,650
滚动文字的时候也是非常迅速

131
00:09:05,650 --> 00:09:09,250
这个的原因也就是实现屏幕缓冲区的方法不同

132
00:09:09,250 --> 00:09:13,800
这个其实是和CPU共享屏幕内存的 （UP注：应该只是共享地址空间）

133
00:09:13,940 --> 00:09:17,800
这样就有一定的优势 尽管会损失一些可用RAM

134
00:09:18,660 --> 00:09:23,920
我找了很久，但是就是找不到任何能支持这个设备的软件

135
00:09:23,920 --> 00:09:28,330
我听说有一个版本的Paperclid字处理软件可以配合这个使用

136
00:09:28,330 --> 00:09:30,970
这个也完全讲得通 因为是一个公司出品的

137
00:09:30,970 --> 00:09:35,040
但是我就是找不到那个版本

138
00:09:35,040 --> 00:09:39,960
但是我就想 如果我要让我自己的程序支持这个设备呢？

139
00:09:41,000 --> 00:09:43,620
几年前我做个一个叫PETDraw的软件

140
00:09:43,620 --> 00:09:47,320
功能就是可以使用内置的字符

141
00:09:47,320 --> 00:09:50,520
包括Commodore在按键上预留的那些小图案

142
00:09:50,520 --> 00:09:55,080
用这些字符在屏幕上作画 当然也是保存、读取

143
00:09:56,140 --> 00:10:00,640
其中一个功能就是可以在伪图形模式中作图

144
00:10:00,640 --> 00:10:04,860
 实际上也就使用字符集中的方块字符

145
00:10:05,560 --> 00:10:08,700
他会自动选取需要的字符

146
00:10:08,700 --> 00:10:10,720
这样用起来就感觉像是真的在用图形模式一样

147
00:10:10,960 --> 00:10:14,590
你可能会被一些字符画的效果震惊到

148
00:10:15,520 --> 00:10:20,600
我做完这个程序后 我就想着能不能移植到Commodore Plus/4上 我这么做了

149
00:10:20,600 --> 00:10:23,580
而且能用 而且能利用上完整的128种颜色

150
00:10:24,020 --> 00:10:25,420
然后我又想 为什么在这止步

151
00:10:25,430 --> 00:10:27,680
我想看看能不能移植到Commodore PET上

152
00:10:27,680 --> 00:10:31,790
PET没有颜色 所以我就把和彩色相关的代码都删掉了

153
00:10:32,380 --> 00:10:35,820
做了那个之后我又想 那80列的PET呢？

154
00:10:35,830 --> 00:10:37,270
于是我也做了那个

155
00:10:37,270 --> 00:10:41,340
当然 我自己没有PET 所以我只在模拟器里见过

156
00:10:41,340 --> 00:10:48,680
但是似乎这个80列的PET版本移植到C64+BI-80平台上非常简单

157
00:10:48,680 --> 00:10:54,880
毕竟 两个系统使用的就是6545 CRTC+80列屏幕

158
00:10:55,160 --> 00:10:59,000
我需要的只是修改源码中的几个屏幕内存地址

159
00:10:59,000 --> 00:11:00,480
而且 也确实就这样就行了

160
00:11:00,840 --> 00:11:05,250
我没改logo，所以显示的仍然是PET 8032版本

161
00:11:05,250 --> 00:11:09,000
但是其它的功能都能在C64上正常使用

162
00:11:09,000 --> 00:11:14,180
所以 现在C64平台上至少有一个软件支持这个东西了

163
00:11:14,700 --> 00:11:17,700
我已经更新了网站上的PETDraw

164
00:11:17,700 --> 00:11:21,980
现在已经能够支持这个卡带了

165
00:11:21,980 --> 00:11:25,060
但是这个卡带就不行了 至少没法简单实现

166
00:11:25,060 --> 00:11:30,820
可能是要完全重写才能够支持他的写入方式吧

167
00:11:31,240 --> 00:11:36,340
好了 我和大家讲过要展示4种在C64上显示80列文字的方法

168
00:11:36,350 --> 00:11:38,990
到目前为止已经讲了3种了

169
00:11:38,990 --> 00:11:42,000
然而虽然我确实很喜欢这些卡带

170
00:11:42,000 --> 00:11:48,660
但是这些卡带很难找到 而且即使找到了也会很贵

171
00:11:49,660 --> 00:11:52,060
所以并不是一个好的选择

172
00:11:52,060 --> 00:11:55,300
第四个选项说出来你可能要我说忽悠你 就是 

173
00:11:57,060 --> 00:11:58,520
直接买个C128

174
00:11:58,640 --> 00:12:01,180
这个基本上就是一台C64

175
00:12:01,400 --> 00:12:06,520
而且比任何这种卡带都要常见 便宜

176
00:12:07,300 --> 00:12:12,360
而且128的做法其实我觉得比较疯狂 就是直接装两块视频芯片

177
00:12:12,480 --> 00:12:17,600
一片80列的芯片 只使用用RGB接口输出 

178
00:12:17,600 --> 00:12:21,400
而传统的40列芯片使用复合视频输出

179
00:12:21,400 --> 00:12:27,600
感觉就是 他们拿了张这种卡带 然后强行集成进去了一样

180
00:12:27,740 --> 00:12:29,560
我一直感觉这更像是一种hack

181
00:12:29,560 --> 00:12:33,360
而不是合适的让它们支持80列的方法

182
00:12:33,360 --> 00:12:37,940
而且最终也不是很成功 因为需要一个单独的显示器

183
00:12:37,940 --> 00:12:39,920
使用的也是完全不同的接口

184
00:12:39,920 --> 00:12:42,570
但是这就是另外一集的内容了

185
00:12:42,570 --> 00:12:49,520
然而C128内部的8563芯片确实能产生非常清晰锐利的80列视频

186
00:12:49,520 --> 00:12:53,920
而且最大能达到16色 看起来就很舒服

187
00:12:53,920 --> 00:12:58,180
然而这需要一台RGB显示器才行

188
00:12:58,180 --> 00:12:59,500
或者 真得吗

189
00:12:59,760 --> 00:13:04,880
很多人都不知道 但是如果你去看C128的RGB接口的引脚定义的话

190
00:13:04,880 --> 00:13:08,160
就会发现第七脚写的是复合视频

191
00:13:08,460 --> 00:13:12,870
所以 只要有合适的连接线 你是可以把它直接连上一个复合视频显示器的

192
00:13:12,870 --> 00:13:14,850
然而只能是黑白

193
00:13:14,850 --> 00:13:20,080
但是如果你有一台单色显示器的话 效果就会和RGB一样清晰

194
00:13:20,080 --> 00:13:24,540
一个优点是 它会输出一些灰度 而不是只有黑和白

195
00:13:24,960 --> 00:13:30,940
所以最后一个问题 为什么这些东西从来就没有流行过

196
00:13:31,400 --> 00:13:34,780
我经常问我自己这个问题

197
00:13:34,780 --> 00:13:38,240
我觉得原因是多方面的

198
00:13:38,240 --> 00:13:40,870
第一个原因就有点像“catch-22” （第22条军规 现用于形容矛盾情况）

199
00:13:40,870 --> 00:13:48,720
没有人想买这些东西 因为没有软件支持

200
00:13:48,820 --> 00:13:55,440
另外一方面 显然也不会有开发者给它们开发软件

201
00:13:55,440 --> 00:13:57,460
因为没什么人买这个东西

202
00:13:57,460 --> 00:14:01,020
所以说就是尴尬

203
00:14:01,020 --> 00:14:02,590
但是这只是一个原因

204
00:14:02,590 --> 00:14:05,880
我觉得还有一些其它的原因

205
00:14:06,580 --> 00:14:11,020
另一个问题就是 这样的设备至少有两种 而且我相信还有第三种

206
00:14:11,020 --> 00:14:13,240
而且他们还互相不兼容

207
00:14:13,240 --> 00:14:15,960
所以如果一个软件开发者要支持80列

208
00:14:15,960 --> 00:14:20,920
他们就得各买一张卡带 然后做三个不同版本的软件

209
00:14:20,920 --> 00:14:23,360
而在Apple II上的80列卡

210
00:14:23,360 --> 00:14:28,270
苹果有官方的卡 也有第三方卡

211
00:14:28,270 --> 00:14:29,900
但是他们互相都是兼容的

212
00:14:29,900 --> 00:14:32,880
所以如果你要给Apple II写80列的软件

213
00:14:33,040 --> 00:14:35,640
你基本可以认定它能在任意一张卡上运行

214
00:14:36,420 --> 00:14:44,940
还要一个问题就是大部分的C64用户都没有一台 能够清晰显示80列文字的显示器

215
00:14:45,060 --> 00:14:49,220
所以说这又是一笔额外的开支

216
00:14:49,220 --> 00:14:54,020
这样想的话 C128上的80列芯片其实也是没成功过

217
00:14:54,020 --> 00:14:58,160
只有一小部分能够支持这个的软件

218
00:14:58,170 --> 00:15:00,930
这些机器最后也基本变成了游戏机

219
00:15:00,930 --> 00:15:05,820
所以说商用软件的需求也本来就不是很强

220
00:15:06,820 --> 00:15:11,210
好了 本期视频就到这里

221
00:15:11,210 --> 00:15:13,580
我们下次见