1
00:00:09,270 --> 00:00:13,740
大家吼，这集我来和大家聊聊上古时期的电脑的图形

2
00:00:14,476 --> 00:00:16,620
我们先来讲几个数字

3
00:00:16,748 --> 00:00:18,060
在上个世纪80年代

4
00:00:18,188 --> 00:00:20,764
一般的家用电脑具有16KB的内存

5
00:00:20,910 --> 00:00:22,524
一些有32KB

6
00:00:22,748 --> 00:00:24,188
如果你用得很壕的电脑，或许有64KB

7
00:00:26,476 --> 00:00:28,287
接下来来讲讲显示内存（显存）

8
00:00:28,460 --> 00:00:31,788
当时的视频芯片并没有自己的内存芯片

9
00:00:31,948 --> 00:00:33,868
所以不得不和CPU共享

10
00:00:34,108 --> 00:00:37,868
当时一般的屏幕分辨率是320*200像素

11
00:00:38,172 --> 00:00:42,652
稍微算下就可以知道屏幕上一共有64000个像素

12
00:00:43,021 --> 00:00:44,716
再来讲讲颜色

13
00:00:44,956 --> 00:00:46,942
如果你只要一种颜色

14
00:00:47,148 --> 00:00:48,604
也就是只有黑色或白色

15
00:00:48,876 --> 00:00:53,292
你将需要整整8KB的内存仅仅用来存储屏幕内容

16
00:00:55,647 --> 00:00:59,020
对于这些电脑来说，这个内存占用还算合理

17
00:00:59,180 --> 00:01:01,932
还是留下了一些给游戏的代码使用

18
00:01:02,156 --> 00:01:04,732
如果增加到16种颜色

19
00:01:04,991 --> 00:01:07,292
显然你需要32KB的内存

20
00:01:07,516 --> 00:01:10,076
这就直接超过了很多电脑所拥有的内存

21
00:01:10,253 --> 00:01:12,380
如果需要使用256色

22
00:01:12,559 --> 00:01:15,964
那就直接吃完了高端电脑的所有内存

23
00:01:16,156 --> 00:01:18,156
于是就没有内存用来跑代码了

24
00:01:18,396 --> 00:01:22,204
如果使用现在的24bit真彩色标准那就直接是不可能了

25
00:01:22,413 --> 00:01:25,244
于是当时的工程师必须使用一些奇技淫巧

26
00:01:25,420 --> 00:01:28,172
来在不使用太多RAM的情况下显示更多的颜色

27
00:01:28,364 --> 00:01:31,932
实际上主要有三种方法，我一个个讲

28
00:01:32,237 --> 00:01:34,604
第一种是颜色单元法

29
00:01:34,876 --> 00:01:36,828
很多系统都使用这种方法，包括Commodore和红白机

30
00:01:37,100 --> 00:01:41,420
NTSC伪色法，主要使用于Apple II和Tandy Color Computer

31
00:01:41,676 --> 00:01:47,228
CPU驱动图形法，主要使用于Atari 2600和Sinclair ZX81

32
00:01:47,548 --> 00:01:51,500
第一种要提到的方法无疑是最流行的

33
00:01:51,742 --> 00:01:55,484
他们的做法基本上就是把整个屏幕分成小的部分

34
00:01:55,708 --> 00:01:58,028
然后这些小的部分被称为颜色单元

35
00:01:58,220 --> 00:02:01,452
接着你可以改变每一个单元的颜色

36
00:02:02,220 --> 00:02:03,743
让我来演示下具体的实现方法

37
00:02:04,252 --> 00:02:08,204
假设这是一个纯黑的屏幕，我们来放大看像素

38
00:02:08,460 --> 00:02:12,333
我现在画了像素的分割线

39
00:02:12,524 --> 00:02:14,604
接着在屏幕上放一点演示用的字符

40
00:02:15,005 --> 00:02:19,678
现在屏幕就是一个1bit模式，像素只能亮或者不亮

41
00:02:19,932 --> 00:02:22,124
那么如何增加颜色呢

42
00:02:22,429 --> 00:02:26,926
把屏幕分成8像素高8像素宽的小格

43
00:02:27,260 --> 00:02:31,084
每个小格可以独立定义前景色和背景色

44
00:02:31,308 --> 00:02:33,164
所以我可以让这个字变成黄色

45
00:02:33,501 --> 00:02:34,636
然后这个变成蓝(zi)色

46
00:02:34,861 --> 00:02:36,284
也可以让背景色变蓝

47
00:02:36,700 --> 00:02:41,021
所以可以看见，这确实给黑白的屏幕带来了一点色彩

48
00:02:41,212 --> 00:02:46,860
而且每个单元只使用一字节来存储前景和背景色

49
00:02:47,038 --> 00:02:53,228
也就是整个屏幕只使用9KB内存（黑白模式使用8KB）

50
00:02:53,404 --> 00:02:54,716
这是一个不错的权衡

51
00:02:55,072 --> 00:02:57,532
接下来就要遇到麻烦了

52
00:02:57,772 --> 00:03:00,636
比如说你想在这里放一条白色的线

53
00:03:00,844 --> 00:03:05,276
这就完全做不到了，因为每个单元只能有2种颜色

54
00:03:05,484 --> 00:03:10,413
所以你看见了这种方法如何让电脑可以同时在屏幕上显示16种颜色

55
00:03:10,572 --> 00:03:13,596
但是你却不能让颜色按你想要的方式去分布（

56
00:03:13,804 --> 00:03:16,876
可以想象的是，这让艺术创作变得非常有挑战性

57
00:03:17,068 --> 00:03:20,445
不过，来看看这个在Commodore64上实现的画作

58
00:03:20,652 --> 00:03:22,318
看起来非常得有色彩（……）

59
00:03:22,540 --> 00:03:27,023
甚至意识不到之前提到的那个限制

60
00:03:27,228 --> 00:03:29,932
但是让我们放大

61
00:03:30,108 --> 00:03:31,884
仔细来看看

62
00:03:32,076 --> 00:03:35,324
并且加上像素的边界线和单元的边界线

63
00:03:35,548 --> 00:03:40,348
你就能看到实际上每个单元都没有超过两种颜色

64
00:03:40,540 --> 00:03:42,876
但是艺术家非常得努力

65
00:03:43,037 --> 00:03:45,148
让他的作品（中的元素）和单元的边界对齐

66
00:03:45,388 --> 00:03:47,292
才让这种限制不那么明显

67
00:03:47,660 --> 00:03:52,060
知道这点应该会让你更加敬佩它的作者

68
00:03:52,301 --> 00:03:55,292
另外如果你是一个红白机玩家

69
00:03:55,452 --> 00:03:59,021
就要知道每一个游戏都得对付完全一样的问题

70
00:03:59,228 --> 00:04:02,028
颜色单元在Commodore64和红白机上稍稍有点不同

71
00:04:02,268 --> 00:04:04,093
但是问题还是相同的

72
00:04:05,229 --> 00:04:08,220
这些工程师知道这个限制是个问题

73
00:04:08,430 --> 00:04:12,236
所以他们给了软件开发者另外一个选择

74
00:04:12,397 --> 00:04:14,332
回到之前的双色例子

75
00:04:14,540 --> 00:04:17,996
C64具有一个多色（Multi-color）模式

76
00:04:18,173 --> 00:04:21,711
做法就是让像素变2倍宽（就我觉得好恶心么）

77
00:04:21,980 --> 00:04:24,076
也就是让屏幕分辨率减半

78
00:04:24,444 --> 00:04:26,893
小的文字看起来相当糟糕

79
00:04:27,260 --> 00:04:29,645
但是当然也能获得好处

80
00:04:29,825 --> 00:04:33,388
你用一些像素换来了一些颜色

81
00:04:33,596 --> 00:04:36,332
它依然使用9KB的内存

82
00:04:38,492 --> 00:04:40,796
现在每个单元允许你使用4种颜色

83
00:04:41,055 --> 00:04:42,812
于是就可以做些像这样的事情

84
00:04:43,053 --> 00:04:46,540
这是一个用多色模式实现的作品的演示

85
00:04:46,796 --> 00:04:51,660
放大看细节就能看到颜色具体是如何运用的

86
00:04:53,087 --> 00:04:56,604
每个单元内仍然不会超过4种颜色

87
00:04:56,892 --> 00:05:00,478
大多数Commodore64的游戏使用这种模式

88
00:05:00,700 --> 00:05:03,308
因为通常颜色比分辨率更为重要

89
00:05:04,252 --> 00:05:09,645
另外一种工程师提供的功能叫做硬件精灵生成

90
00:05:09,884 --> 00:05:11,548
来看看这是如何工作的

91
00:05:12,108 --> 00:05:14,748
现在这张图上画一个精灵（sprite）

92
00:05:14,925 --> 00:05:17,741
这也就是80年代那些开发者做的事情

93
00:05:18,780 --> 00:05:21,213
接着我们需要把它给转换成二进制数据

94
00:05:21,420 --> 00:05:23,324
让我来演示下如何实现

95
00:05:23,548 --> 00:05:26,268
每个像素对应于一个0或者1

96
00:05:26,510 --> 00:05:30,493
把它分成三个部分，每个部分横向8像素

97
00:05:30,748 --> 00:05:36,221
来看前8个像素，因为没有东西，所以写0

98
00:05:36,382 --> 00:05:43,742
接下来这里就有点东西了，为了方便我使用计算器来把二进制转成十进制

99
00:05:43,964 --> 00:05:45,852
于是得到了124

100
00:05:46,204 --> 00:05:48,812
最后一部分也是0

101
00:05:49,692 --> 00:05:53,004
就这样一路写下来

102
00:05:53,324 --> 00:05:56,348
接下来把这些东西输入（Commodore64）计算机的内存

103
00:05:56,572 --> 00:05:58,620
接着让它显示出来

104
00:06:00,076 --> 00:06:02,700
注意到我没有办法在这上面打字

105
00:06:02,908 --> 00:06:04,972
也没有办法通过打字改变它的位置

106
00:06:05,196 --> 00:06:07,628
即使我改变文字的颜色也完全没有关系

107
00:06:07,868 --> 00:06:10,414
精灵和剩下的屏幕是完全独立的

108
00:06:10,604 --> 00:06:12,700
甚至连颜色单元都不影响

109
00:06:12,956 --> 00:06:16,188
我可以通过调整寄存器来改变这个精灵的颜色

110
00:06:16,367 --> 00:06:19,660
或者通过另外的寄存器来移动它在屏幕上的位置

111
00:06:19,980 --> 00:06:22,876
清屏指令也不会把它清掉

112
00:06:23,644 --> 00:06:26,044
精灵在游戏当中使用非常广泛

113
00:06:26,316 --> 00:06:28,365
不同的主机拥有不同的精灵数量

114
00:06:28,590 --> 00:06:31,372
Commodore64支持8个不同的精灵

115
00:06:31,564 --> 00:06:34,188
红白机则支持64个精灵

116
00:06:34,364 --> 00:06:36,156
然而每个精灵的尺寸小得多

117
00:06:36,348 --> 00:06:39,548
也就是需要使用更多的精灵来达到同样的效果

118
00:06:39,758 --> 00:06:43,436
比如马里奥其实是由4个不同的精灵组成的

119
00:06:43,853 --> 00:06:48,445
但是程序让它们一直在一起所以看起来就像一个一样

120
00:06:48,668 --> 00:06:50,447
好了，第一部分就到这里

121
00:06:50,764 --> 00:06:57,132
请期待第二部分，里面将解释Apple II的图形和其它更早的CPU直接产生的图形

122
00:06:58,092 --> 00:07:00,524
注：本视频为早期视频，现已更名为The 8-Bit Guy

