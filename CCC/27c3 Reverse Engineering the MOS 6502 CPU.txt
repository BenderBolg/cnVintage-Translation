所以6502为什么吸引人呢
毕竟当时也有其他成功的CPU，例如Z80
但一比较你就会发现，6502比Z80少了60%的晶体管
优化做得好多了
虽然并不能说6502性能强劲但是比Z80还快（2倍）
6502受限较多，但是也更优雅
有些人认为优雅来源于简洁……
本讲会由三部分构成
第一部分自顶向下，讲programming model、如何和CPU交互等内容
所以别觉得无聊……
第二部分自底向上，讲如何拆解6502、门电路、拍照片、从门级理解内部原理
第三部分自内向外，讲我们从对6502的解构中学到了什么 我们对元器件知道些什么 元器件之间如何交互
那些奇怪的XX是怎么来的
 
 一般而言 当接触到一个新的CPU的时候 人们一般会去看datasheet
 不过我们还是……直接看代码吧……
 
 对于不了解6502汇编的人……让我们一起来看一下这边
 STA = store accumulator 
 A，X，Y三个寄存器
 JSR = jump to subroutine 
 LDA = load accumulator
 CMP = compare the A register
 BCC = branch if carry clear
 BEQ = branch equal
 然后还有加法指令， 每次做加法之前必须把进位标志清除，因为Carry也会被加
 
 在这个底层汇编层面我们感兴趣的是对应的编码。操作符都是1 byte，负责编码指令和寻址模。操作数可以是0、1或2 byte。比如CLC清除进位指令没有操作数，是一个1 byte的指令。而JSR分支跳转指令是3 byte的，地址占2 byte也就是16 bit。但是我们注意到这边第一个指令STA 是向内存存数据，而内存地址应该是16 bit的。不过因为这个地址在内存的第一页，可以这么简写，能让指令更短、更快。
 从理论角度，
 A寄存器，也就是累加器。做算术和逻辑运算时的数据都要经该寄存器储存中转。
 
 X和Y寄存器都是索引寄存器，
 可自增或自减，用来访问数组。但是不能对这两个寄存器做算数或逻辑运算。
 
 状态位寄存器P有8 bit
 其中4 bit是关于算术逻辑的，1 bit指示十进制模式——后面我会讲这个模式的。虽然很无聊（
 另有2 bit是关于异常的。
 程序计数器PC是16 bit。栈指针也是16 bit，不过高8位是硬编码固定的，所以实际上只有8 bit。
 
 接下来是一些实际应用。
 寻址空间是64 kb。前两页（每页256 bit）比较特殊。第一页是0页，从0到FF。这一页内的寻址可以使用特殊的编码，只用1 byte，指令更短更快。而且有些事情只能在第0页做。因为6502系统的寄存器数量很少，所以第0页很有用。栈内存占据了第1页，从01FF到0100.
 这张PPT看起来很复杂，不过接下来会更复杂（
 让我们来对所有指令有个什么指令干什么事情的总览。
 不过你用不着把什么都记住。
 
 Load指令，把数据从内存加载到寄存器。
 Store指令，把数据从寄存器存到内存。
 可以在寄存器之间转移数据。
 有两类RMW（读改写）指令。一类是移位指令，对累加器或者内存数据移位。另一类是对内存或者索引寄存器自增自减。
 
 ALU负责加法和减法指令和布尔逻辑运算指令，以及这边的比较指令，本质上就是做只存标志位不存结果的减法。还有BIT指令就是只存标志位的AND运算。
 
 关于标志位：你可以设置或清除某些标志位，
 你也可以根据标志位是否被设置来做条件跳转。
 
	
 
 还有无条件跳转，JSR分支跳转 RTS由分支跳回 BRK是软中断 RTI从中断跳回
 
 对于栈，只能push或者pull A寄存器或者状态位寄存器。
 
 这些就是所有指令了。
 
 对于通用指令，以下是可以使用的寻址方式。
 直接寻址，使用常数。	Immediate
 绝对寻址				Absolute
 绝对变址寻址 			Absolute, X or Y
 0页面变址寻址			Zeropage
 变址间接寻址			Zeropage, X or Y
 0页面变址间接寻址		(Zero Page, X)
 间接寻址				(Zero Page),Y
 
 间接寻址可以用来避免某些设计上的限制或缺陷。
 
 让我们通过例子来详细看一下是怎么寻址的。
 
 直接寻址：相当于是加载一个常数到寄存器。本例中是把常数17存到A寄存器。
 绝对寻址意味着带着一个16 bit的操作数，也就是内存中的位置。本例中我们从内存中找到314这个位置存的数，31。所以寄存器A中的数值是31.
 0页面寻址：这个带有优化的。操作数只有8 bit。我们从内存位置2加载数据0，于是A寄存器就是0。
 绝对变址寻址：意味着内存地址是绝对地址+寄存器内数据。所以本例中把X寄存器中的数字A加到常数200上得到20A这个指针，指向内存中的20A位置，是52这个数，于是A寄存器是52. 比如说如果我们有一个从内存200处开始的数组，我们就可以用X寄存器来遍历这个数组。
 绝对值+X和绝对值+Y是一码事。
 类似的方式可用于0页面。有趣的是用于0页面的变址寻址是会循环的。比如这边这个例子，如果得到的结果大于FF，也就是超出了0页面的边界，那地址就会变回0，从头开始不会越界。
 
  间接寻址要更有趣一点。注意到，我们连16位的寄存器都没有（全是8位的……），那如何寻址到16位的内存空间呢？可以先把地址存到0页面， 然后用0页面的数据作为指针。比如本例，我们把0页面80+X也就是8C处开始的一个数组来作为指针。8C处是3F，接下来的8D处是C4，由于这里用的是小端序（稍有常识的人都知道的正统端序），所以指针会指向C43F，并从该处把数据加载到A。这是XXXXX，所以就很慢了，大概需要5到6个CPU指令周期。