1
00:00:09,037 --> 00:00:11,204
这个演讲是关于复古的

2
00:00:12,126 --> 00:00:17,867
内容是 关于Commodore 64的几乎一切

3
00:00:20,047 --> 00:00:21,152
行 那我们开始吧

4
00:00:21,328 --> 00:00:23,624
有请Michael Steil

5
00:00:33,069 --> 00:00:34,633
Hi

6
00:00:36,347 --> 00:00:39,447
大家好 今天我要谈一谈Commodore 64

7
00:00:39,620 --> 00:00:41,442
你可能听说过这个机器

8
00:00:41,442 --> 00:00:44,242
主要是因为最近的复古热潮

9
00:00:44,270 --> 00:00:46,074
很多人都在玩C64

10
00:00:46,074 --> 00:00:50,056
比如这个人在Xserve上运行C64模拟器

11
00:00:50,147 --> 00:00:53,280
这个人在办公室的MacPro旁边放了一台C64

12
00:00:53,608 --> 00:00:58,117
甚至有人在自己的车牌上玩C64的梗

13
00:00:58,510 --> 00:01:02,305
但是我这里想说很重要的一点

14
00:01:02,438 --> 00:01:05,649
就是你可以做好的芯片设计 也可以做差的芯片设计

15
00:01:05,649 --> 00:01:07,544
C64就是一个非常好的设计

16
00:01:07,544 --> 00:01:09,859
如果你把它和当时其它的机器对比

17
00:01:10,057 --> 00:01:14,150
比如说IBM CGA卡 它们能寻址同样容量的内存

18
00:01:14,203 --> 00:01:18,644
然而CGA的图像是那样的 C64的是这样的

19
00:01:18,785 --> 00:01:21,948
或者使用一些技巧能达到这种效果

20
00:01:22,247 --> 00:01:29,400
而且在编程上也是一样 你可以用很笨的方法 也可以很有创造性

21
00:01:29,492 --> 00:01:31,154
如果你决定做 周期精确 的代码

22
00:01:31,154 --> 00:01:32,987
那你能做的事情真得非常多

23
00:01:32,987 --> 00:01:35,193
然而有个问题就是 这种编码艺术是否已经被遗失了

24
00:01:35,193 --> 00:01:39,244
所以我今天要讲讲关于那样的编程

25
00:01:39,674 --> 00:01:43,612
这些是我今天要讲的一些点

26
00:01:44,218 --> 00:01:46,025
我有64分钟的时间

27
00:01:46,089 --> 00:01:48,577
以及256张幻灯片

28
00:01:51,699 --> 00:01:55,390
Commodore公司在1954年由Jack Tramiel创立

29
00:01:55,620 --> 00:01:56,750
这是他近期的照片

30
00:01:58,064 --> 00:01:59,570
他们生产计算器

31
00:01:59,759 --> 00:02:03,629
之后买下了MOS公司

32
00:02:03,876 --> 00:02:06,863
MOS是个芯片厂

33
00:02:07,307 --> 00:02:09,954
总工程师是Chuck Peddle

34
00:02:10,169 --> 00:02:12,184
这是他近期的视频

35
00:02:12,657 --> 00:02:14,628
他们设计制造了6502 CPU

36
00:02:14,628 --> 00:02:17,607
最初用途是工业控制

37
00:02:17,876 --> 00:02:23,885
但是他们后来又基于6502做了一个KIM1计算机套件

38
00:02:24,568 --> 00:02:28,788
Commodore觉得把它扩展成家用电脑应该不错

39
00:02:28,982 --> 00:02:33,787
于是就有了面向小型企业和教育的Commodore PET电脑

40
00:02:33,873 --> 00:02:38,738
同时还开始销售面向家用的Commodore VIC-20

41
00:02:39,980 --> 00:02:43,087
VIC-20是个非常精简的计算机系统

42
00:02:43,370 --> 00:02:50,901
它的后续型号就是C64 带有64KB的内存 在当时算是相当多了

43
00:02:50,932 --> 00:02:56,540
如果放到市面上对比 如果想要64KB内存基本上都得花上1000刀

44
00:02:56,580 --> 00:02:59,213
这还只是主机 不包括显示器或者软驱

45
00:02:59,438 --> 00:03:04,738
而C64售价只有595美金

46
00:03:07,535 --> 00:03:10,511
C64也有一个后续型号 C128

47
00:03:11,323 --> 00:03:13,277
和C64兼容 于是销量挺好

48
00:03:13,537 --> 00:03:17,223
以及Plus/4 不兼容前代 销量就不太好

49
00:03:18,656 --> 00:03:24,610
在1982年和1994年期间 他们卖出了1700万台C64

50
00:03:24,813 --> 00:03:27,307
让C64成为了有史以来销量最高的电脑

51
00:03:27,307 --> 00:03:30,251
加上300万台C128

52
00:03:31,238 --> 00:03:33,197
这是C64的样子

53
00:03:33,477 --> 00:03:34,748
他有很多不同的型号

54
00:03:34,808 --> 00:03:36,166
这个是最初的型号

55
00:03:36,245 --> 00:03:38,773
他们生产过一种扁平的升级版

56
00:03:39,634 --> 00:03:42,543
然后又用回了最初的设计 因为更便宜

57
00:03:42,635 --> 00:03:45,139
他们生产过Golden Version

58
00:03:45,326 --> 00:03:46,179
限量版

59
00:03:46,363 --> 00:03:48,007
便携版

60
00:03:48,240 --> 00:03:50,217
以及还有这个

61
00:03:55,838 --> 00:03:59,455
C64开机后大概就是这个样子的

62
00:03:59,465 --> 00:04:02,263
会直接启动进ROM内的BASIC环境

63
00:04:02,263 --> 00:04:07,329
你可以直接开始写BASIC代码 也可以从磁带或者软盘载入程序

64
00:04:07,881 --> 00:04:10,662
为了给大家一个对于图形性能的印象

65
00:04:10,785 --> 00:04:14,814
这是一个非常早期的官方demo——1982圣诞节demo

66
00:04:14,979 --> 00:04:17,689
之后的demo大多是这样的

67
00:04:19,326 --> 00:04:22,649
再之后的demo有非常好的图形效果

68
00:04:22,864 --> 00:04:29,287
可能会有一些3d效果 或者是其它的一些特效

69
00:04:30,343 --> 00:04:33,745
早期的游戏 如Loderunner 长的是这样的

70
00:04:34,796 --> 00:04:38,180
之后的看起来更复杂一些

71
00:04:40,657 --> 00:04:45,562
甚至再之后的使用了之前根本做不到的图形模式

72
00:04:46,259 --> 00:04:47,999
都是使用同样的 未修改过的硬件系统

73
00:04:49,716 --> 00:04:52,570
所以我们先从外表来看C64

74
00:04:52,908 --> 00:05:00,215
在右侧有两个手柄接口 可以连接手柄或者是手柄+鼠标

75
00:05:01,256 --> 00:05:09,392
背部有扩展接口 你可以连接几乎所有东西 因为这是直接连接到CPU总线的

76
00:05:09,668 --> 00:05:22,662
各种扩展硬件 大部分人都是连接外部ROM 比如扩展库 BASIC程序 比如这个Final Cartridge

77
00:05:22,882 --> 00:05:35,638
还有RF接口 复合视频接口 用于连接软驱及打印机的IEC串口 还有磁带接口

78
00:05:35,638 --> 00:05:37,896
以及连接剩下各种东西的用户口

79
00:05:39,489 --> 00:05:42,195
一个典型的系统就是这样的

80
00:05:42,195 --> 00:05:47,437
一台C64加上一台1541软驱 以及一台Commodore显示器

81
00:05:48,030 --> 00:05:49,852
拆开来 这是主板

82
00:05:50,958 --> 00:05:58,021
左边有6510 CPU 和6502很接近

83
00:05:59,402 --> 00:06:04,982
两个6526 CIA 也就是IO控制器

84
00:06:06,024 --> 00:06:13,249
在右边有6581 SID音频芯片 以及VIC视频芯片

85
00:06:16,243 --> 00:06:21,504
所以我们依次谈一谈这些元件

86
00:06:22,284 --> 00:06:30,993
6502是在1975年由MOS公司的工程师团队设计的 他们刚刚从摩托罗拉跳槽过来

87
00:06:31,359 --> 00:06:33,759
总工程师Chuck Peddle

88
00:06:33,773 --> 00:06:36,986
他们手里拿的是晶片照片

89
00:06:38,553 --> 00:06:41,905
这是芯片的原理图 你很快就会理解的

90
00:06:44,082 --> 00:06:48,337
这个就是它的汇编的样子

91
00:06:48,337 --> 00:06:51,182
指令代码长度是1-3字节

92
00:06:51,469 --> 00:06:54,907
也就是1字节的操作码加上0-2字节的操作数

93
00:06:55,822 --> 00:06:58,497
这是一个8位cpu 有3个寄存器

94
00:06:58,731 --> 00:07:01,965
一个累加寄存器A 可以执行数学和逻辑计算

95
00:07:02,282 --> 00:07:09,837
两个索引寄存器X和Y 可以用于索引 不能用来做计算 但是他们可以自加自减

96
00:07:10,081 --> 00:07:14,665
一个处理器状态 包括 负结果 溢出 零结果 进位 还有些其它的位

97
00:07:14,982 --> 00:07:16,955
16位的程序计数器（PC）

98
00:07:17,287 --> 00:07:25,914
一个8位的栈指针寄存器 等效16位 前八位是锁死的1

99
00:07:26,194 --> 00:07:30,965
这也就暗示了基于6502系统的内存地址结构

100
00:07:31,809 --> 00:07:37,507
内存中的第0页很特殊 我之后会具体讲

101
00:07:38,154 --> 00:07:45,965
第1页永远都是栈 因为栈指针永远指向0x100到0x1FF这256字节之间

102
00:07:45,965 --> 00:07:47,001
向下生长

103
00:07:48,337 --> 00:07:52,538
这是所有支持的操作码

104
00:07:52,907 --> 00:07:58,009
总共256的操作码中大约有150个是有效的

105
00:08:00,414 --> 00:08:02,449
我来简要讲一遍指令集

106
00:08:02,449 --> 00:08:11,930
有载入指令 存储指令 可以对累加器进行移位操作 可以让XY寄存器自加或者自减

107
00:08:12,610 --> 00:08:22,048
以及加法和减法指令 永远都是带进位的 所以有进位需要显式设定

108
00:08:23,179 --> 00:08:27,877
这是布尔逻辑 比较 BIT指令

109
00:08:28,132 --> 00:08:36,748
红的是读取指令 蓝的是写入指令 而交叉部分就是读-改-写指令

110
00:08:37,051 --> 00:08:40,790
绿框内的是数学指令和逻辑指令

111
00:08:41,123 --> 00:08:50,518
黄圈内的只影响状态位而不会写入结果

112
00:08:52,066 --> 00:09:01,555
具体指令不同 支持的寻址模式也不同

113
00:09:01,725 --> 00:09:05,178
第一个我想讲的是立即数寻址模式

114
00:09:05,178 --> 00:09:11,484
这个所有的读取指令都能支持

115
00:09:11,860 --> 00:09:16,098
如果代码里有个井号就说明是立即数寻址模式

116
00:09:16,350 --> 00:09:23,204
在这个例子中就是直接把17存入累加器A

117
00:09:23,391 --> 00:09:25,991
绝对地址寻址模式就是读取内存

118
00:09:26,211 --> 00:09:29,523
我有一个两字节（16bit）操作数

119
00:09:29,743 --> 00:09:31,858
整个指令编码成3字节

120
00:09:32,213 --> 00:09:40,225
执行效果就是从内存地址0x0314中读取字节 存入累加器A

121
00:09:40,469 --> 00:09:44,954
第0页寻址则是6502另外一个不错的一个优化功能

122
00:09:45,207 --> 00:09:53,104
每次需要从内存地址0-255之中读取数据的时候

123
00:09:53,104 --> 00:09:56,837
指令编码只需要2字节而不是3字节 速度就能快一些

124
00:09:57,457 --> 00:10:04,161
举个例子 就是这样 读取数据 载入累加器

125
00:10:05,516 --> 00:10:08,287
绝对地址+X 寻址模式

126
00:10:08,541 --> 00:10:12,664
用途是用来读取查找表

127
00:10:13,165 --> 00:10:17,400
首先先把X加到指定的地址中

128
00:10:17,400 --> 00:10:21,136
例子的话就是200+X

129
00:10:21,402 --> 00:10:28,383
于是就是从020A读取52存入累加器

130
00:10:28,754 --> 00:10:33,497
绝对地址+Y 寻址模式也是一个意思

131
00:10:33,762 --> 00:10:34,960
只是用Y来表示而已

132
00:10:35,240 --> 00:10:40,675
比如例子的话就是访问一个最大可以到256字节的数组

133
00:10:42,116 --> 00:10:46,187
第0页+X 也是一样的优化

134
00:10:46,507 --> 00:10:53,084
注意现在使用的时候，读取的地址不能超过第0页

135
00:10:53,314 --> 00:10:58,748
计算结果超出0-255就会被截取

136
00:10:58,955 --> 00:11:02,755
同样的 还有第0页+Y

137
00:11:02,963 --> 00:11:11,496
这个比较少见，只有两个指令能用这个寻址模式

138
00:11:11,762 --> 00:11:14,534
第0页+X 间接寻址模式

139
00:11:14,932 --> 00:11:18,856
就直接把第0页当成是一个指针数组

140
00:11:19,150 --> 00:11:25,578
于是就把X先加到指定的地址 然后读取那个地址所指向的地址

141
00:11:25,658 --> 00:11:34,408
例子中就是80+X，也就是8C

142
00:11:34,622 --> 00:11:47,461
读取到C43F 然后再读取C43F得到54

143
00:11:48,000 --> 00:11:54,298
第零页间接+Y寻址模式 看起来差不多 但是并不一样

144
00:11:54,553 --> 00:11:57,608
它首先读取指针再加上Y

145
00:11:57,965 --> 00:12:04,355
也就是只有一个指针 然后给指针加上偏移量

146
00:12:04,651 --> 00:12:12,774
先读取14 得到地址D800 加上Y是D828

147
00:12:13,044 --> 00:12:15,881
最后读取D828得到0B

148
00:12:15,881 --> 00:12:18,194
因为整个系统没有16位寄存器

149
00:12:18,400 --> 00:12:24,978
所以当需要使用指针的时候 就需要把指针存在第0页然后用这个模式

150
00:12:25,253 --> 00:12:29,678
如果不需要偏移 那就直接把Y设置成0就行了

151
00:12:31,189 --> 00:12:35,064
接下来是寄存器寻址模式

152
00:12:35,322 --> 00:12:37,803
比如说累加器的移位指令

153
00:12:37,803 --> 00:12:42,690
自加自减指令 都是直接对寄存器操作

154
00:12:42,690 --> 00:12:45,900
不需要额外的参数

155
00:12:47,060 --> 00:12:50,674
A X Y之间的寄存器复制指令

156
00:12:50,912 --> 00:12:55,113
另外还可以在X和堆栈指针之间复制

157
00:12:55,413 --> 00:13:00,050
说到堆栈的话 堆栈从01FF开始向下生长

158
00:13:00,368 --> 00:13:05,885
比如我压一个数进去 那就在堆栈指针指向的地址存入数据

159
00:13:05,885 --> 00:13:07,704
然后对指针自减

160
00:13:08,045 --> 00:13:12,556
再存一个 还是一样 存储 自减

161
00:13:12,936 --> 00:13:22,590
而要退栈的时候 就先自加指针 然后读出数据存入累加器

162
00:13:26,503 --> 00:13:33,603
流程控制指令有跳转 间接跳转 跳转到子函数 其实也就是CALL

163
00:13:33,713 --> 00:13:38,303
如果你对摩托罗拉熟悉的话 那这些助记符应该也不会陌生

164
00:13:38,443 --> 00:13:41,460
然后是RTS 也就是返回指令

165
00:13:41,460 --> 00:13:48,030
有趣的是 保存到栈上的地址是当前地址+2

166
00:13:48,260 --> 00:13:57,642
然而跳转指令是3字节长度 所以在读取时需要再+1

167
00:13:57,891 --> 00:14:01,102
对于优化而言 芯片这个设计相当有趣

168
00:14:03,859 --> 00:14:09,043
内存最高地址存放的是中断向量

169
00:14:09,616 --> 00:14:13,134
分别是NMI（不可屏蔽中断）、RESET（复位中断） 和IRQ（常规中断）

170
00:14:13,426 --> 00:14:15,974
中断相关的指令有BRK（中断）和RTI（返回）

171
00:14:15,974 --> 00:14:19,742
BRK指令也就是软件中断

172
00:14:20,018 --> 00:14:24,452
执行时首先把当前PC+2压入栈 就像JSR一样

173
00:14:24,851 --> 00:14:26,503
随后压入原来的处理器模式 并设置新的处理器模式

174
00:14:26,503 --> 00:14:29,545
最后跳转到中断向量地址

175
00:14:29,545 --> 00:14:36,838
区分软件中断和硬件中断的方法就是看状态位

176
00:14:36,838 --> 00:14:40,591
软件中断情况下BREAK位会被置高

177
00:14:40,700 --> 00:14:47,358
而RTN指令则就是把处理器模式和PC出栈

178
00:14:47,749 --> 00:14:54,046
因为没有直接把X、Y寄存器压栈或出栈的方法

179
00:14:54,046 --> 00:14:57,612
所以为了保护寄存器数值 一般的中断向量是这样的

180
00:14:57,612 --> 00:15:09,284
先压入A 然后X赋值到A 压入A 最后同样压入Y 关闭10进制模式（一会具体讲）

181
00:15:10,235 --> 00:15:17,510
结束时也就是出栈 然后赋值到Y 到X 最后是A 返回

182
00:15:17,595 --> 00:15:26,545
跳转指令可以根据4个标志位进行 负 零 溢出 和 进位

183
00:15:26,645 --> 00:15:28,710
比如有如果正数则跳转 如果负数则跳转一类的

184
00:15:29,937 --> 00:15:39,642
如果未进位则跳转 和 如果进位则跳转 可以用于数字大小

185
00:15:40,184 --> 00:15:44,851
比如这个例子中 我从内存地址中读取一个数字 然后和5进行比较

186
00:15:45,144 --> 00:15:50,136
如果没有进位，则说明这个数字小于5，那就会执行跳转

187
00:15:50,361 --> 00:15:55,643
可以看见跳转指令使用1字节的相对地址编码的

188
00:15:55,829 --> 00:16:03,739
所以跳转是地址无关的 但是只能跳转到跳转指令1字节后+127~-128的范围

189
00:16:05,012 --> 00:16:08,713
大部分的状态位都可以直接置位或者清零

190
00:16:08,713 --> 00:16:16,940
可以设置十进制位 也可以通过设置中断屏蔽位来启用或者关闭中断

191
00:16:17,228 --> 00:16:22,945
手动置位或者清除进位可以在加减法中用到

192
00:16:22,945 --> 00:16:29,398
因为加减法都是自动带进位计算的 所以在加法计算前就得手动清除进位

193
00:16:29,624 --> 00:16:32,782
而减法计算前就必须手动设置进位

194
00:16:33,594 --> 00:16:35,866
现在是关于十进制模式

195
00:16:35,953 --> 00:16:37,890
这个实际上还是有专利的

196
00:16:37,960 --> 00:16:44,955
他们额外实现了一个用于处理BCD的模式 虽然现在已经没太大用了

197
00:16:45,165 --> 00:16:48,857
不过当时来说似乎还是非常重要的

198
00:16:49,082 --> 00:16:53,800
比如如果把0x09和0x02相加，会得到0x0B

199
00:16:53,993 --> 00:16:55,892
也就是一般的十六进制加法

200
00:16:56,076 --> 00:16:59,118
但是如果开启十进制模式

201
00:16:59,118 --> 00:17:01,820
每次加减后就会进行十进制调整

202
00:17:02,161 --> 00:17:06,294
所以0x09加上0x02，结果会是0x11

203
00:17:06,524 --> 00:17:09,738
这是具体的实现方法 但是目前而言并不重要

204
00:17:10,172 --> 00:17:13,431
我想讲讲一个重要的指令 NOP

205
00:17:13,769 --> 00:17:20,223
我想把它的行为全部放在1页PPT上 但是有点困难 不过还是这样了

206
00:17:22,793 --> 00:17:25,826
所以现在来看一小段代码

207
00:17:27,061 --> 00:17:35,212
这个代码来自于PET Update的Commodore BASIC v2

208
00:17:35,980 --> 00:17:39,670
这个是微软写的 而且其实是个彩蛋

209
00:17:39,945 --> 00:17:45,148
如果执行WAIT 6502就会显示Microsoft

210
00:17:46,029 --> 00:17:53,883
具体实现就是 首先从第0页载入第一个参数的低字节

211
00:17:54,132 --> 00:17:56,291
比较6502的低字节

212
00:17:56,593 --> 00:17:58,163
如果不是就先跳转走

213
00:17:58,408 --> 00:18:01,312
然后再比较高字节 相减看看是否为0

214
00:18:01,641 --> 00:18:05,626
也得符合条件 所以如果不等于就跳转走

215
00:18:05,865 --> 00:18:09,244
现在初始化指针

216
00:18:09,627 --> 00:18:12,164
同样把Y寄存器清零

217
00:18:12,554 --> 00:18:16,345
这个其实是屏幕内存地址的高位

218
00:18:16,685 --> 00:18:21,170
把它存入参数1 这样也就能作为第0页的指针使用

219
00:18:21,473 --> 00:18:26,481
这个是个计数器 指示字符串中的字符数

220
00:18:26,721 --> 00:18:29,604
从字符串中载入一个字节

221
00:18:29,604 --> 00:18:34,576
而且其实字符串的高位是乱码 所以清除高位

222
00:18:34,576 --> 00:18:36,837
存储进屏幕内存

223
00:18:36,837 --> 00:18:40,410
对指针进行自加

224
00:18:40,933 --> 00:18:42,741
BNE进行循环

225
00:18:42,920 --> 00:18:45,334
自加指针的高位

226
00:18:45,649 --> 00:18:50,740
如果需要的话 自减读取用的指针

227
00:18:50,965 --> 00:18:55,630
再是一个循环 可以用于显示多次

228
00:18:57,237 --> 00:19:01,634
这个代码很有可能是比尔盖茨本人写的

229
00:19:01,845 --> 00:19:04,409
有充分的证据证明这一点

230
00:19:04,448 --> 00:19:06,928
如果他都能写6502代码，那么你一定也可以

231
00:19:13,264 --> 00:19:16,112
接下来是关于周期计数的

232
00:19:16,112 --> 00:19:25,366
如果需要给6502设备编程 这个是个非常重要的技能 多多少少会需要用到

233
00:19:25,366 --> 00:19:32,661
一个基本的法则就是 一次内存操作就是1个时钟 所有指令至少需要2个时钟

234
00:19:32,800 --> 00:19:35,140
所以再来看一次这个例子

235
00:19:35,140 --> 00:19:42,006
参数1是第0页寻址 如果是绝对地址那就是4个周期 但是这里是3个周期

236
00:19:42,006 --> 00:19:49,369
因为本身LDA就是2个字节 加上第0页读取1个字节 一共3个

237
00:19:49,609 --> 00:19:55,345
比较是一个双字节指令 没有额外的读取 所以就是2

238
00:19:55,659 --> 00:20:00,987
跳转也是双字节 也就是2个周期 如果跳转了那就需要再加一个周期

239
00:20:01,183 --> 00:20:05,402
相同的略

240
00:20:05,402 --> 00:20:10,294
有趣的是这个 这个是个绝对地址+偏移载入

241
00:20:10,294 --> 00:20:16,523
绝对地址载入本身已经是3字节了 然后内存读取 又是一个周期

242
00:20:16,684 --> 00:20:22,687
如果有加法进位那还得再加一个周期

243
00:20:23,002 --> 00:20:25,400
下面的基本就是这样 复杂的指令需要更长的时间

244
00:20:25,742 --> 00:20:31,074
返回需要6个周期 跳转执行函数也是一样的

245
00:20:32,741 --> 00:20:36,872
6502有几个芯片bugs必须要避开

246
00:20:37,108 --> 00:20:43,910
虽然后续的版本中有修复 但是C64使用的全部是有bug的芯片

247
00:20:44,329 --> 00:20:48,449
当然有的时候不升级对于兼容性来说非常重要

248
00:20:48,776 --> 00:20:50,835
比如说你有一个间接跳转

249
00:20:51,130 --> 00:20:54,397
所以它应该从这个地方（20FF）读取要跳转到的地址的低字节

250
00:20:54,475 --> 00:20:56,276
从这个地方读取（2100）读取要跳转到的地址的高字节

251
00:20:56,276 --> 00:20:58,873
但是实际实现中没有实现进位 就变成从2000读取高字节了

252
00:20:59,588 --> 00:21:02,736
所以避免使用这个指令

253
00:21:02,944 --> 00:21:09,366
这个就比较迷了 因为软件角度下一般是察觉不到这个bug的

254
00:21:09,620 --> 00:21:14,445
但是如果你使用了MMIO硬件就能发现区别

255
00:21:14,717 --> 00:21:22,427
如果你要自加某个数字 它会在写入正确的数值前执行一次多余的存储

256
00:21:22,624 --> 00:21:25,418
Ghost Read也是一样的问题

257
00:21:25,636 --> 00:21:32,521
如果说是X偏移的存储 它会在原始地址读取一次 而不是+X的地址

258
00:21:32,621 --> 00:21:36,219
比如这个例子中 在C64上它将会响应所有中断

259
00:21:36,416 --> 00:21:39,061
尽管根本不应该读写这个地址

260
00:21:39,475 --> 00:21:44,116
如果在这个位置发生中断 BRK指令可能会被丢失

261
00:21:44,533 --> 00:21:48,053
所以说避免使用

262
00:21:49,133 --> 00:21:54,404
还有一个问题就是关于无效的指令码

263
00:21:54,549 --> 00:22:04,678
有很多指令码是未定义的 但是他们并没有把这些指令设置成NOP或者是死机一类的

264
00:22:04,678 --> 00:22:07,114
而是会执行其它指令的结合

265
00:22:09,187 --> 00:22:12,466
有一部分 比如这些会让机器死机

266
00:22:12,516 --> 00:22:14,964
其它的 有个这样的表

267
00:22:15,165 --> 00:22:19,125
就是一些组合 有些还是有点用的

268
00:22:19,125 --> 00:22:24,724
比如说存储A&X（与运算）到某个地址

269
00:22:24,724 --> 00:22:27,724
这个还是有意义的 而且也可以在软件里面用

270
00:22:27,724 --> 00:22:31,724
在C64上这些操作码都是有效的 确实可以使用

271
00:22:32,818 --> 00:22:36,238
这是其它的

272
00:22:36,550 --> 00:22:43,520
接下来讲一些C64(或者其它6502机)的编程技巧

273
00:22:44,200 --> 00:22:48,770
如果只使用寄存器的话 每次调用函数都只能传输3个字节的参数

274
00:22:48,874 --> 00:22:54,044
因为栈操作非常复杂 所以肯定也不想把参数放在栈上

275
00:22:54,937 --> 00:23:00,077
最好的方法是把东西全部扔在第0页

276
00:23:01,587 --> 00:23:04,677
RTS跳转页还是很有用的

277
00:23:04,827 --> 00:23:08,827
把向量从表里读取出来 放在栈上 然后执行一次RTS

278
00:23:09,354 --> 00:23:16,154
当然编码的时候需要把地址-1 因为RTS会自动把地址+1

279
00:23:17,911 --> 00:23:23,591
如果你想要节省一点内存 这个技巧还是很常用的

280
00:23:25,941 --> 00:23:29,941
比如说这个例子当中 先做个比较 然后如果相同跳转到L1

281
00:23:30,315 --> 00:23:33,815
载入一个字节然后调用显示字符

282
00:23:33,815 --> 00:23:38,505
如果没有跳转，我也想显示字符

283
00:23:38,505 --> 00:23:40,065
但是JMP PRINTCHAR这样就要3个字节了

284
00:23:40,995 --> 00:23:44,229
然而其实可以直接跳过下面一个LDA #0x53

285
00:23:44,229 --> 00:23:47,769
一种方法就是用一个BNE

286
00:23:47,769 --> 00:23:51,769
但是我还可以用一个.BYTE $2C

287
00:23:51,769 --> 00:23:57,479
实际运行时 如果没有发生跳转 下一条指令会被解码为BIT指令

288
00:23:58,349 --> 00:24:01,909
这样就占位消耗掉了后面两个字节的指令

289
00:24:01,909 --> 00:24:07,539
BIT指令会把这个地址的东西和累加器中的进行与运算 然后设置状态寄存器

290
00:24:07,540 --> 00:24:09,130
但是不会存储其它任何数据

291
00:24:09,130 --> 00:24:11,450
所以在这里基本也就是一个NOP

292
00:24:11,770 --> 00:24:14,960
于是就执行到后面的指令了 而且也只浪费了一个字节

293
00:24:15,187 --> 00:24:17,337
虽然慢了点 但是省下了两个字节

294
00:24:19,123 --> 00:24:23,123
修改本身代码在6502系统中也是很常用的

295
00:24:23,339 --> 00:24:26,439
比如这个例子 是用来清空C64的屏幕缓冲区的

296
00:24:26,508 --> 00:24:33,728
虽然说确实可以用第0页间接Y索引模式

297
00:24:34,111 --> 00:24:39,681
但是如果用绝对Y寻址会简单的多 也快得多

298
00:24:40,001 --> 00:24:44,001
然后用一个自加指令 直接对这个字节自加

299
00:24:44,299 --> 00:24:47,189
如果代码不是在ROM中执行的话

300
00:24:49,028 --> 00:24:50,548
再来看一次框图

301
00:24:50,548 --> 00:24:52,858
现在可以理解一部分了

302
00:24:52,858 --> 00:24:56,138
PC逻辑非常的复杂

303
00:24:56,866 --> 00:25:02,286
周期计数器用于计数目前在一个指令的第几个周期

304
00:25:02,313 --> 00:25:04,793
这个指令寄存器 操作码被缓存在这里

305
00:25:05,079 --> 00:25:11,049
这两个一起传输到指令解码器

306
00:25:11,085 --> 00:25:15,605
于是 根据目前的指令和执行的状态

307
00:25:15,796 --> 00:25:26,546
它会输出一些命令 让寄存器从总线上读取数据 或者把数据输出到总线上

308
00:25:26,879 --> 00:25:30,879
而且也决定了ALU需要做什么

309
00:25:32,073 --> 00:25:33,723
再来看一遍晶片照片

310
00:25:33,777 --> 00:25:35,017
左边的是解码器ROM

311
00:25:35,647 --> 00:25:39,647
中间是所有的逻辑部分 包括ALU

312
00:25:39,914 --> 00:25:41,514
右边是寄存器

313
00:25:41,956 --> 00:25:44,266
6502用了大约4000个门

314
00:25:44,266 --> 00:25:48,266
对比下现在的CPU大约需要20000000个

315
00:25:48,674 --> 00:25:55,864
可以看见 仅仅只是5个寄存器 其实就基本占到了整个CPU的一半

316
00:25:57,228 --> 00:26:03,328
6502和Z80一样十分重要 在非常非常多的设备中都有应用

317
00:26:03,828 --> 00:26:07,828
比如说Apple I 目前已经成为了非常稀有的收藏品

318
00:26:08,052 --> 00:26:15,052
Apple II系列 BBC Micro 所有的Atari 8-bit电脑

319
00:26:15,052 --> 00:26:23,862
游戏机 掌机 任天堂的8-bit和16-bit游戏机 还有这个

320
00:26:26,686 --> 00:26:29,386
C64用的是6510

321
00:26:29,393 --> 00:26:37,583
其实完全就是6502加上6个额外的IO引脚 用于内存切换一类的

322
00:26:37,994 --> 00:26:40,694
主频将近1MHz

323
00:26:44,381 --> 00:26:48,161
有了额外的IO，就可以控制RAM的开关

324
00:26:48,161 --> 00:26:54,671
6502的一个问题就是它只能寻址64K的内存 但是C64本身就已经有了64K的RAM

325
00:26:54,671 --> 00:26:56,601
那么ROM和IO区域往哪放呢

326
00:26:57,292 --> 00:27:00,032
这是正常的内存布局

327
00:27:00,032 --> 00:27:03,382
但是你可以关闭这些ROM

328
00:27:03,693 --> 00:27:09,453
在BASIC之下这又是一块RAM

329
00:27:09,453 --> 00:27:14,413
有趣的是 如果你往ROM写入数据 会直接写到ROM下方的RAM当中

330
00:27:16,437 --> 00:27:18,467
内核也是可以关闭的

331
00:27:18,550 --> 00:27:22,550
IO区域下面的不单单有RAM 还有字符ROM

332
00:27:22,828 --> 00:27:26,828
如果想要修改内部字符集就可以在这里操作

333
00:27:27,735 --> 00:27:29,455
来看看IO部分

334
00:27:29,456 --> 00:27:33,456
这里有视频控制器、音频控制器的MMIO

335
00:27:33,456 --> 00:27:39,656
这里还有1KB的Color RAM 也就是外部的VRAM

336
00:27:40,266 --> 00:27:47,636
2个IO控制器 还有两个空位 用于扩展

337
00:27:49,402 --> 00:27:54,662
来看看两个ROM 先讲内核 直接位于硬件之上

338
00:27:55,074 --> 00:27:59,074
里面有硬件初始化和测试代码 也包括中断向量

339
00:27:59,640 --> 00:28:15,360
RTC模拟代码 RS232库代码 可以用于用户口 键盘驱动 屏幕驱动

340
00:28:15,360 --> 00:28:21,280
用于软驱、打印机的IEC总线驱动 磁带机的驱动

341
00:28:21,462 --> 00:28:25,992
在屏幕和键盘驱动之上是屏幕编辑器

342
00:28:26,188 --> 00:28:34,948
也就是负责控制光标移动 还有在按下回车时把之前输入的内容存入输入缓冲区

343
00:28:36,775 --> 00:28:40,775
在软驱驱动和磁带IO之上的是文件IO

344
00:28:40,907 --> 00:28:46,477
在这一切之上 是字符IO库

345
00:28:47,842 --> 00:28:51,042
所有这些东西通过库调用接口导出

346
00:28:51,042 --> 00:28:56,402
也就是ROM顶部的一张跳转表

347
00:28:58,175 --> 00:29:00,640
其中有一个就是字符输出

348
00:29:00,640 --> 00:29:03,640
位置就是FFD2 现在就能理解这个梗是什么了

349
00:29:06,210 --> 00:29:08,890
如何配合内核来编程 我就用了一个简单的例子

350
00:29:08,918 --> 00:29:12,918
实现了cat命令 也就是读取文件输出到stdout

351
00:29:13,129 --> 00:29:15,619
所以我先打开了文件 设备号为8

352
00:29:15,695 --> 00:29:18,105
这是文件名 调用打开函数

353
00:29:18,157 --> 00:29:20,357
设置stdin到那个通道

354
00:29:20,761 --> 00:29:24,761
读取一个字符 输出到stdout上 也就是屏幕

355
00:29:24,873 --> 00:29:28,763
读取状态判断是否达到文件尾部

356
00:29:28,833 --> 00:29:30,733
如果已经到达那就关闭文件

357
00:29:30,800 --> 00:29:34,800
然后复位stdin

358
00:29:36,656 --> 00:29:40,656
但是如果能够写BASIC代码 谁会想去写汇编呢

359
00:29:41,835 --> 00:29:47,985
C64内部的BASIC也是基于标准的Microsoft BASIC的

360
00:29:49,168 --> 00:29:53,168
微软最初为i8080开发了BASIC解释器

361
00:29:53,382 --> 00:29:58,592
在1975他们把它移植到了别的8-bit平台上 比如6502

362
00:29:58,669 --> 00:30:00,566
它被授权给很多很多厂家

363
00:30:00,566 --> 00:30:02,416
包括苹果和Commodore

364
00:30:03,145 --> 00:30:06,295
第一版被用于最初的PET

365
00:30:06,295 --> 00:30:07,545
但是因为实在有太多的bug

366
00:30:07,545 --> 00:30:11,545
Commodore又要求MS编写了一个升级的第二版

367
00:30:11,640 --> 00:30:12,977
然后继续随PET发售

368
00:30:12,977 --> 00:30:15,047
但是在这之后他们就再也没去找过MS

369
00:30:15,047 --> 00:30:18,007
自己改代码进行修改

370
00:30:18,266 --> 00:30:22,266
到了第四版增加了一些额外的磁盘指令

371
00:30:22,612 --> 00:30:25,612
用于PET和晚期的V4

372
00:30:25,879 --> 00:30:28,549
到了C64 他们是在v4的代码基础上

373
00:30:28,611 --> 00:30:34,131
再把所有磁盘指令去掉 只剩下8KB 但是之前的bug修复还在

374
00:30:34,226 --> 00:30:40,846
C64和VIC20使用的都是升级后修复了bug的BASIC版本

375
00:30:41,412 --> 00:30:45,412
这个是Microsoft Commodore BASIC的指令集

376
00:30:45,537 --> 00:30:46,637
应该说非常基础

377
00:30:47,064 --> 00:30:51,064
橙色的是Commodore后来加上的磁盘IO命令

378
00:30:51,958 --> 00:30:55,298
它的功能非常有趣

379
00:30:55,298 --> 00:30:57,918
因为他们实现了一个挺不错的浮点库

380
00:30:57,918 --> 00:31:01,918
如果需要浮点支持 第三方汇编程序也可以调用这个库

381
00:31:01,962 --> 00:31:05,962
这个算是个非常通用的BASIC 除了6502没有其它的硬件依赖

382
00:31:08,345 --> 00:31:14,055
其它的都直接调用内核代码 其实基本也就是内核stdio调用

383
00:31:16,070 --> 00:31:21,730
所以在BASIC中 可用的内存范围是0800一直到A000

384
00:31:21,792 --> 00:31:31,842
不能被BASIC使用的RAM块可以用来放汇编代码

385
00:31:33,427 --> 00:31:35,717
这样也就是系统内大约38K可用内存的来源了

386
00:31:35,717 --> 00:31:38,367
不过BASIC并不是非常友好

387
00:31:38,431 --> 00:31:42,431
另外其实还有一个图形操作系统 叫做GEOS

388
00:31:42,594 --> 00:31:50,874
这个基本就是抄的1984年的Mac OS

389
00:31:51,023 --> 00:31:54,103
功能也是几乎一样的

390
00:31:54,381 --> 00:31:58,381
对于只有64K内存的8位机来说其实是相当厉害了

391
00:31:58,936 --> 00:32:06,116
GEOS的开发商Berkeley Softworks也额外开发了一些应用程序

392
00:32:06,258 --> 00:32:13,638
比如geoCalc 是一个表格程序 速度还是比较慢的

393
00:32:14,528 --> 00:32:19,238
一个数据库软件 还有一个桌面出版软件

394
00:32:19,748 --> 00:32:23,748
GEOS并没有使用内核或者BASIC 所以就把所有ROM都关闭了

395
00:32:24,305 --> 00:32:32,695
内存映射中有两个屏幕缓冲区 很多代码 内部数据

396
00:32:32,805 --> 00:32:34,560
最后剩下一些给应用程序

397
00:32:34,560 --> 00:32:38,010
GEOS同样也有一个syscall跳转表

398
00:32:38,527 --> 00:32:42,527
但是如果你不想借助任何现成的库，想要自己编程的话

399
00:32:42,865 --> 00:32:44,605
就得先了解这些芯片

400
00:32:44,887 --> 00:32:47,827
这个是CIA（复杂接口适配器），一共有两个

401
00:32:48,081 --> 00:32:59,321
每个各自有16个GPIO 两个16位定时 和 当日时间的时钟

402
00:32:59,321 --> 00:33:00,908
其中最后一个内核没有用到

403
00:33:01,969 --> 00:33:09,559
CIA1被内核用于系统时钟 并且在这之上模拟了RTC

404
00:33:09,559 --> 00:33:15,769
另外在键盘驱动和中断服务程序中也用到了CIA1

405
00:33:16,437 --> 00:33:20,437
两个摇杆接口和键盘连接到了CIA的GPIO上

406
00:33:20,833 --> 00:33:24,143
键盘阵列是长这样的

407
00:33:25,116 --> 00:33:29,116
C64大约有64个按键

408
00:33:29,116 --> 00:33:32,576
所以刚好可以放进8x8的矩阵

409
00:33:32,821 --> 00:33:36,821
一边的8条线连到了PA输出

410
00:33:36,821 --> 00:33:39,441
另外一边的则是PB输入

411
00:33:39,609 --> 00:33:43,609
比如按下右SHIFT的时候就短接了两条线

412
00:33:44,033 --> 00:33:49,153
如果循环分别设置其中一个列线为1

413
00:33:49,481 --> 00:33:53,481
就能检查到这个短接

414
00:33:53,769 --> 00:33:57,769
然后PA6+PB4 就知道我按的是右SHIFT了

415
00:33:58,031 --> 00:34:05,991
CIA2接管的是IEC总线和用户接口

416
00:34:08,009 --> 00:34:12,569
接下来是音频 著名的SID 6581

417
00:34:12,763 --> 00:34:15,403
内置3个独立的声部

418
00:34:17,553 --> 00:34:25,953
SID的设计非常有趣 因为它是数字模拟混合设计

419
00:34:25,953 --> 00:34:29,703
大部分都是由数字逻辑控制的

420
00:34:29,703 --> 00:34:36,623
但是一些滤波器是模拟的 就提供了一些难以模拟的效果

421
00:34:37,432 --> 00:34:48,022
三个声部 每个声部都可以分别是 锯齿波 三角波 方波 和 杂波 其中的任意一种

422
00:34:48,202 --> 00:34:57,000
每个声部都支持标准的ADSR包络控制

423
00:34:57,390 --> 00:35:01,553
模拟的滤波器 低通 高通 波段

424
00:35:01,788 --> 00:35:04,849
对于特殊的需求

425
00:35:04,983 --> 00:35:12,955
还有3 Ring Modulators还有Oscillator Sync

426
00:35:13,151 --> 00:35:16,758
不要问我这个是干什么的 我也不知道 我不懂音乐

427
00:35:16,995 --> 00:35:20,083
但是如果你想具体了解的话 都在这个专利当中

428
00:35:20,083 --> 00:35:24,548
关于SID我知道的一点就是关于如何播放采样音乐

429
00:35:25,291 --> 00:35:27,710
原版的SID有个小缺陷

430
00:35:27,710 --> 00:35:29,510
每次你改变音量的时候

431
00:35:29,622 --> 00:35:34,072
就是调整4bit的主音量寄存器的时候 它会有个小的click

432
00:35:34,176 --> 00:35:37,886
所以如果一直修改的话 想播放什么都行

433
00:35:37,972 --> 00:35:41,972
所以如果想要播放采样音频 就弄个循环 一直写入音量寄存器就可以了

434
00:35:42,067 --> 00:35:43,627
这个也就是给了你第四个声部

435
00:35:43,787 --> 00:35:50,467
所以不少音乐会拿它来当鼓点声部

436
00:35:54,135 --> 00:35:58,135
我更加感兴趣的是视频控制器 VIC

437
00:35:58,167 --> 00:36:04,947
MOS 6569（PAL）或者6567（NTSC）

438
00:36:06,006 --> 00:36:12,286
VIC支持40x25文字模式 或者320x200的图形模式

439
00:36:12,708 --> 00:36:14,848
可以寻址16KB的显存

440
00:36:15,019 --> 00:36:18,099
带有16种内建颜色

441
00:36:18,333 --> 00:36:27,613
这是C64内置的完整字符集 默认为大写 但是也可以切换为小写

442
00:36:28,236 --> 00:36:32,236
VIC支持256钟不同的字符

443
00:36:32,826 --> 00:36:36,826
每个屏幕上的字符可以分别拥有16钟不同的颜色之一

444
00:36:37,124 --> 00:36:39,884
每个字符是8x8像素

445
00:36:40,074 --> 00:36:42,524
使用0和1的位图编码

446
00:36:42,666 --> 00:36:47,396
每一行都是一个字节 保存在字符ROM中

447
00:36:48,923 --> 00:36:53,273
所以如果VIC想要知道屏幕上应该显示什么颜色

448
00:36:53,324 --> 00:36:55,014
它会首先读取屏幕内存

449
00:36:56,022 --> 00:37:00,502
然后根据索引值在字符ROM中找到对应的字节和位

450
00:37:00,627 --> 00:37:08,087
如果是1 则读取颜色RAM中的颜色 否则就使用屏幕背景颜色

451
00:37:08,308 --> 00:37:11,148
另外还有一种扩展背景模式(Extended Background Mode)

452
00:37:11,148 --> 00:37:14,068
这种情况下 能够使用的字符只有64个

453
00:37:14,271 --> 00:37:16,461
但是可以使用4种不同的背景色

454
00:37:16,724 --> 00:37:19,214
加上之前的不同的前景色

455
00:37:19,601 --> 00:37:24,133
这个模式下 字符只使用屏幕内存的0-5位

456
00:37:24,133 --> 00:37:27,133
一样的 颜色内存

457
00:37:27,133 --> 00:37:35,243
省出来的最高两位现在就用于指定4钟不同的背景色了

458
00:37:36,591 --> 00:37:39,841
另外还有一个多色模式 对于文字模式来说意义不大

459
00:37:39,841 --> 00:37:47,031
不过也有一些简单的使用文字界面来做的游戏

460
00:37:47,031 --> 00:37:51,031
现在就每个方格就可以使用最多四种颜色了

461
00:37:51,435 --> 00:37:54,655
在这个模式下 像素就不再是正方形了

462
00:37:54,655 --> 00:37:56,205
是原来的两倍宽度

463
00:37:56,205 --> 00:37:58,785
也就是2位来编码一个像素

464
00:37:59,754 --> 00:38:02,604
屏幕内存依然是字符的索引

465
00:38:03,179 --> 00:38:13,279
三种颜色来自于屏幕背景色 剩下一钟可以从色彩RAM中自由选择

466
00:38:13,513 --> 00:38:20,273
如果你再加上最高位的话 这样每个字符使用不同的模式也是完全可以的

467
00:38:21,879 --> 00:38:24,419
图形模式

468
00:38:24,577 --> 00:38:28,027
这个是Commodore官方早期给出的一个demo

469
00:38:28,115 --> 00:38:36,035
但是分辨率受限于320x200双色 虽然有多色模式 但是还有一些额外的限制

470
00:38:36,042 --> 00:38:38,392
比如仔细看这张图

471
00:38:38,445 --> 00:38:40,205
可以看见确实是方形的像素

472
00:38:40,237 --> 00:38:42,857
但是仔细看这个

473
00:38:42,931 --> 00:38:46,001
如果把网格铺上

474
00:38:46,015 --> 00:38:48,955
可以看见每个8x8的小方块里只能有2种不同的颜色

475
00:38:51,174 --> 00:38:57,874
编码如图 也是0和1 所以和字符的编码方式是完全一致的

476
00:38:59,165 --> 00:39:03,675
如果是0的话 就从屏幕内存读取颜色

477
00:39:03,675 --> 00:39:08,505
屏幕内存现在已经不用存储文字了 因为都是从8KB的图形内存中读取的

478
00:39:09,112 --> 00:39:13,902
0从屏幕内存读 1也从屏幕内存读 分别是4位

479
00:39:14,060 --> 00:39:18,060
所以就能有两种颜色 总调色板16色

480
00:39:18,630 --> 00:39:22,130
另外同样的有一个多色模式

481
00:39:22,130 --> 00:39:26,630
一样 现在像素就不是方形了 而是长方形的

482
00:39:26,630 --> 00:39:31,850
如果画上网格 每块都是4x8的网格 每块里可以有四种不同的颜色

483
00:39:32,501 --> 00:39:39,601
其中一种组合代表屏幕背景 另外两个来自屏幕内存

484
00:39:39,601 --> 00:39:41,511
还有一个来自色彩内存

485
00:39:41,558 --> 00:39:50,098
所以所有的方块都得使用一样的背景色 但是剩下3个 不同的方块可以自由选择

486
00:39:51,818 --> 00:39:53,698
接下来是软件卷动

487
00:39:54,405 --> 00:40:00,285
图像可以以字节为单位向左或者向右卷动

488
00:40:00,480 --> 00:40:03,940
问题就是，如果你往右移动了7个像素

489
00:40:03,984 --> 00:40:08,304
下一次再卷动的时候 如果想要在多出来的地方显示内容是做不到的

490
00:40:08,304 --> 00:40:12,296
因为没有地方存储第41行的数据

491
00:40:12,865 --> 00:40:16,865
于是可以切换到38列模式

492
00:40:17,119 --> 00:40:19,639
纵向也可以这么玩

493
00:40:19,959 --> 00:40:23,959
而且也一样的会从25列变成24列

494
00:40:26,258 --> 00:40:30,068
Commodore64的VIC支持精灵

495
00:40:30,068 --> 00:40:32,778
精灵的尺寸是24x21

496
00:40:33,057 --> 00:40:34,567
一共支持8个精灵

497
00:40:35,749 --> 00:40:42,129
为0的像素是透明的 为1的像素是每个精灵可以单独自由选择的颜色

498
00:40:42,559 --> 00:40:44,939
一样的 还有多色模式

499
00:40:45,601 --> 00:40:52,921
4种颜色 00是透明 一种是可以自由选择的精灵颜色

500
00:40:52,945 --> 00:40:58,535
另外两种是全局设定的精灵颜色

501
00:40:59,285 --> 00:41:04,055
你可以横向缩放 纵向缩放 或者整体缩放 2倍

502
00:41:04,221 --> 00:41:07,231
但是意义就不大 因为分辨率实在是太惨了

503
00:41:07,482 --> 00:41:10,762
但是如果合理使用的话 可以做出这样的图形

504
00:41:10,816 --> 00:41:13,427
那大部分的都是正常的精灵

505
00:41:13,427 --> 00:41:17,807
但是上面的那只鸟 其实是两个缩放过的精灵拼起来的

506
00:41:17,807 --> 00:41:19,107
而且看起来其实也并不是那么惨

507
00:41:20,679 --> 00:41:22,019
精灵优先级

508
00:41:22,151 --> 00:41:26,151
低序号的精灵排在高序号的精灵上面

509
00:41:26,151 --> 00:41:31,331
每个精灵可以单独选择和背景的优先关系

510
00:41:32,052 --> 00:41:34,962
如果你在写游戏 想要检测精灵碰撞

511
00:41:35,030 --> 00:41:36,670
VIC可以帮你完成这一点

512
00:41:36,862 --> 00:41:40,152
如果有两个像素重叠

513
00:41:40,152 --> 00:41:45,202
VIC就会注意到这个问题 之后会在寄存器里设置一个flag 另外也可以产生中断

514
00:41:47,521 --> 00:41:52,521
来看看内存划分是怎么样的

515
00:41:52,681 --> 00:41:55,971
VIC可以寻址16KB的内存

516
00:41:56,131 --> 00:42:02,751
所以也就可以有16个不同的屏幕缓冲区位置 不过必须是1KB对齐的

517
00:42:03,580 --> 00:42:09,980
字符集是2KB大小 所以也可以有8个不同的位置

518
00:42:11,018 --> 00:42:15,208
位图是8KB大小 所以只能有两个位置可选

519
00:42:15,543 --> 00:42:21,193
精灵是64字节 所以可以指定256个不同的位置

520
00:42:23,762 --> 00:42:26,282
但是一次只能显示8个

521
00:42:26,645 --> 00:42:32,065
VIC一次可以寻址16KB 没有自己独立的RAM

522
00:42:32,065 --> 00:42:34,445
而是使用C64的主RAM

523
00:42:35,199 --> 00:42:40,099
所以一共有4个Bank 你可以把视频内存放在任何地方

524
00:42:40,326 --> 00:42:44,326
但是有一个问题需要注意 就是有两个Bank 也就是Bank0和Bank2

525
00:42:44,576 --> 00:42:49,006
里面有一个区域没有办法寻址内存

526
00:42:49,151 --> 00:42:53,151
VIC寻址的时候读取到的不是内存而是字符ROM

527
00:42:53,277 --> 00:42:54,447
所以自己也就没有办法放数据

528
00:42:54,447 --> 00:42:58,707
但是如果你想要使用内置的字符ROM 设置到这两个Bank就可以用了

529
00:42:59,931 --> 00:43:02,751
接下来再深入一些

530
00:43:03,053 --> 00:43:05,833
我之前讲过它的分辨率是320x200

531
00:43:05,833 --> 00:43:08,033
但是这只是可见区域

532
00:43:08,033 --> 00:43:12,033
还有不可见区域 如果你想要玩点花样的话 那一样很重要

533
00:43:12,298 --> 00:43:15,328
所以去掉显示器的边框 来看过扫描的区域

534
00:43:15,464 --> 00:43:18,084
这个是VIC实际绘图的区域

535
00:43:18,382 --> 00:43:19,822
但是其实还有更多

536
00:43:19,822 --> 00:43:23,642
还有行消隐和场消隐区域

537
00:43:23,872 --> 00:43:27,002
没有办法显示任何东西 但是也是在总时序当中的

538
00:43:27,002 --> 00:43:28,752
我下一张幻灯片讲

539
00:43:28,878 --> 00:43:30,828
总的时序看起来就是这样的

540
00:43:30,862 --> 00:43:36,012
如果电子束要绘制图像的话

541
00:43:36,012 --> 00:43:40,402
就是从左上角开始 一行一行

542
00:43:40,402 --> 00:43:45,072
屏幕上的一个字符就是刚好一个机器周期

543
00:43:45,390 --> 00:43:49,390
所以横向的宽度也就是40个周期 频率1MHz

544
00:43:49,438 --> 00:43:52,098
而一整行则是63个周期

545
00:43:53,005 --> 00:43:56,015
这就是电子束绘图的方法

546
00:43:56,015 --> 00:44:02,755
一行一行从左到有右 包括行消隐和场消隐区域

547
00:44:02,958 --> 00:44:06,958
D012是光栅位置寄存器

548
00:44:07,054 --> 00:44:11,284
所以如果电子束刚好在一行的中间

549
00:44:11,415 --> 00:44:14,215
这时如果修改VIC的设置 画面会立即发生变化

550
00:44:14,215 --> 00:44:16,635
这样就能实现一些效果

551
00:44:16,798 --> 00:44:20,098
比如说我在这一行总修改背景颜色

552
00:44:20,098 --> 00:44:25,008
VIC就会从这行中间开始绘制不同的背景色

553
00:44:25,103 --> 00:44:26,883
然后一直这样

554
00:44:27,051 --> 00:44:33,091
所以如果就这样继续的话，下半屏就是白色的了

555
00:44:33,222 --> 00:44:38,392
如果不做修改，下一帧就是全白了，但是如果即使调整回来

556
00:44:38,392 --> 00:44:40,512
就可以只白一帧

557
00:44:40,996 --> 00:44:42,426
如果每一帧都要实现这样的效果的话

558
00:44:42,561 --> 00:44:44,911
但是我又不想一直对比光栅寄存器

559
00:44:44,911 --> 00:44:46,501
我就可以开启一个光栅中断

560
00:44:46,617 --> 00:44:48,607
在这些红点处开启中断

561
00:44:48,955 --> 00:44:53,665
在这里设定好中断 于是屏幕就会先显示到这个位置

562
00:44:53,665 --> 00:44:58,505
触发中断 修改背景颜色 现在显示的就是白色背景

563
00:44:58,505 --> 00:45:00,595
再设置一个中断

564
00:45:00,924 --> 00:45:03,154
触发中断 再设置回来

565
00:45:03,224 --> 00:45:05,374
就把剩下的再画出来了

566
00:45:05,855 --> 00:45:07,985
这个做法在游戏中非常常见

567
00:45:07,985 --> 00:45:11,535
比如这个游戏中就是在字符模式和图形模式中切换

568
00:45:11,535 --> 00:45:15,065
当然其实这个图形也是用字符模式 也就算tile模式完成的

569
00:45:15,431 --> 00:45:21,481
就需要2个光栅中断来完成这个图像分割

570
00:45:21,757 --> 00:45:29,337
这里就需要至少3个光栅中断 来实现3个部分不同的卷动

571
00:45:30,631 --> 00:45:34,631
各种demo也经常使用屏幕分割的方法

572
00:45:34,845 --> 00:45:37,285
另外关于这个demo有趣的一点就是

573
00:45:37,285 --> 00:45:43,585
就是它使用到了屏幕边框以外的区域

574
00:45:44,226 --> 00:45:47,246
首先是这个光栅条

575
00:45:47,246 --> 00:45:48,676
这个非常容易实现

576
00:45:48,676 --> 00:45:54,216
就是一并修改边框颜色和背景颜色就可以了

577
00:45:54,256 --> 00:45:58,256
延迟几个时钟 直到达到下一行 在做同样的修改

578
00:45:59,000 --> 00:46:02,000
这下面还有额外的图形

579
00:46:02,290 --> 00:46:04,380
这个就更麻烦一些了

580
00:46:04,630 --> 00:46:06,020
我现在来解释下

581
00:46:06,020 --> 00:46:12,093
所以各位应该还记得屏幕可以在24行和25行模式之间切换

582
00:46:12,093 --> 00:46:13,763
现在这个是24行

583
00:46:14,543 --> 00:46:16,533
如果仔细看屏幕左下角

584
00:46:16,533 --> 00:46:18,243
这是25行

585
00:46:18,403 --> 00:46:19,713
这是24行

586
00:46:20,074 --> 00:46:26,474
现在要做的就是先把屏幕设置成25行模式

587
00:46:26,854 --> 00:46:28,254
也就是到这里

588
00:46:28,298 --> 00:46:32,298
之后在红点处加一个光栅中断

589
00:46:32,548 --> 00:46:35,088
所以呢就让它一直绘图到红点处

590
00:46:35,719 --> 00:46:42,069
然后设置纵向边框的起始到绿点处

591
00:46:42,263 --> 00:46:49,313
这样就永远不会触发开启边框

592
00:46:49,459 --> 00:46:52,029
就会继续绘图

593
00:46:53,141 --> 00:46:55,551
这样并不会显示更多的字符

594
00:46:55,701 --> 00:46:59,001
因为本来就没有东西能显示了 但是精灵可以显示在额外区域中

595
00:46:59,204 --> 00:47:03,924
正常情况下 精灵是会被边框覆盖的

596
00:47:04,733 --> 00:47:09,943
但是如果用了这个方法 当然每一帧需要单独设置一遍

597
00:47:10,288 --> 00:47:13,668
精灵就是这样的 （这个模式被称为Hyperscreen Mode）

598
00:47:14,349 --> 00:47:17,689
也就可以把精灵放到边框区域里面了

599
00:47:19,075 --> 00:47:20,875
许多游戏也使用了这个方法

600
00:47:20,966 --> 00:47:21,996
比如说这个游戏

601
00:47:22,211 --> 00:47:23,581
这个是真实的屏幕范围

602
00:47:23,791 --> 00:47:26,231
在底部有8个精灵

603
00:47:26,489 --> 00:47:27,639
只是为了显示状态

604
00:47:27,900 --> 00:47:30,610
在最上面有更多的精灵

605
00:47:30,888 --> 00:47:34,738
所以加起来一共有21个精灵 这是怎么做到的呢

606
00:47:34,985 --> 00:47:36,105
其实也很简单

607
00:47:36,260 --> 00:47:39,890
屏幕有很多的部分 就可以设置一堆光栅中断

608
00:47:40,024 --> 00:47:44,024
每一屏都重新设定几遍精灵寄存器就可以了

609
00:47:44,109 --> 00:47:46,609
所以每个部分都可以有8个精灵

610
00:47:50,896 --> 00:47:52,366
这个做法叫做精灵复用

611
00:47:52,537 --> 00:47:59,197
如果复用玩得好的话 比如这种写的很好的复用代码

612
00:47:59,250 --> 00:48:01,360
就可以在屏幕任意地方画精灵

613
00:48:01,360 --> 00:48:02,850
画多少都可以

614
00:48:03,167 --> 00:48:08,257
就可以达到这样的效果 也就是在需要绘制的地方启用精灵

615
00:48:08,487 --> 00:48:12,487
这样就能够使用非常多的精灵了

616
00:48:12,727 --> 00:48:16,417
这个例子中 闪烁问题我觉得应该是模拟器造成的

617
00:48:16,417 --> 00:48:18,927
我觉得原始的游戏应该是没有闪烁问题的

618
00:48:19,972 --> 00:48:21,602
讲到精准的计时

619
00:48:21,739 --> 00:48:27,009
VIC的计时其实挺复杂 有些技巧得完全了解这个计时才能使用

620
00:48:27,278 --> 00:48:34,218
VIC和6502共享了同一块内存 内存的运行速度是2倍

621
00:48:34,218 --> 00:48:35,848
所以可以完美共享

622
00:48:35,848 --> 00:48:42,428
每个上升沿VIC可以访问内存 而每个下降沿6502可以访问内存

623
00:48:42,943 --> 00:48:46,823
因为VIC需要大量的内存访问来显示屏幕内容

624
00:48:46,823 --> 00:48:47,663
比如这样

625
00:48:47,663 --> 00:48:49,593
每个周期都需要1次内存访问

626
00:48:49,593 --> 00:48:54,483
这仅仅是读取屏幕像素内容

627
00:48:55,773 --> 00:48:58,323
这样每行就是40次读取

628
00:48:59,102 --> 00:49:03,102
但是每行字符开始的第一行

629
00:49:03,102 --> 00:49:06,502
还需要单独的读取 因为需要从屏幕内存读取字符索引

630
00:49:07,231 --> 00:49:12,801
这样每个周期就得读取两次

631
00:49:12,801 --> 00:49:14,531
对于内存来说是可行的

632
00:49:14,531 --> 00:49:18,341
但是这样6502就不能再读取内存了

633
00:49:18,341 --> 00:49:21,681
于是那段时间中6502是被挂起的

634
00:49:22,040 --> 00:49:24,540
如果看全图的话

635
00:49:24,540 --> 00:49:28,540
所有这些行中 6502是被关闭的

636
00:49:28,573 --> 00:49:31,453
不能进行任何处理 因为VIC占用了总线

637
00:49:32,262 --> 00:49:34,382
这些行被称为坏行（Bad lines）

638
00:49:34,450 --> 00:49:36,412
检查坏行的方式非常简单

639
00:49:36,672 --> 00:49:49,602
如果光栅寄存器的最低3位和 纵向卷动寄存器的最低3位相同 则这是个坏行

640
00:49:50,024 --> 00:49:53,114
正常情况下 幻灯片上打红叉的地方是坏线

641
00:49:53,219 --> 00:49:55,419
但是如果我在红点处开了一个光栅中断

642
00:49:55,542 --> 00:50:03,422
请确保不要触发这样的事情 也不要修改纵向卷动寄存器让下一行变成坏行

643
00:50:03,522 --> 00:50:08,982
但是这样可以直接把整个屏幕下移而不显示任何东西

644
00:50:10,787 --> 00:50:14,257
所以就可以在不复制任何东西的情况下移动画面

645
00:50:15,984 --> 00:50:19,304
如果看下这个我之前展示过的图片

646
00:50:19,304 --> 00:50:21,494
它使用了许多许多不同的技巧

647
00:50:21,681 --> 00:50:23,741
现在我就挨个讲一遍

648
00:50:24,131 --> 00:50:28,131
也基本上是和坏行有关的

649
00:50:28,575 --> 00:50:29,875
首先来看这里

650
00:50:29,924 --> 00:50:32,294
显然已经是超过16种颜色了

651
00:50:32,530 --> 00:50:34,810
这里的用到的技巧叫做交错

652
00:50:34,982 --> 00:50:38,562
PAL制的C64图像刷新率为50Hz

653
00:50:38,746 --> 00:50:41,216
如果在两种颜色间不停切换

654
00:50:41,444 --> 00:50:45,444
如果颜色很接近你可能就很难看出闪烁

655
00:50:45,730 --> 00:50:47,390
这样就能有一种新的颜色

656
00:50:47,390 --> 00:50:48,900
这样就能得到紫色 这个紫色和内置的紫色是不一样的

657
00:50:48,900 --> 00:50:50,000
这样也就多了一种颜色

658
00:50:50,000 --> 00:50:52,380
理论上来说结合起来应该有256种颜色

659
00:50:53,228 --> 00:50:59,768
但是如果去掉重复的一些颜色 还有闪烁感严重的颜色

660
00:50:59,768 --> 00:51:02,598
基本上也就是多出来十几二十种颜色

661
00:51:04,030 --> 00:51:08,030
所以这个是组合出来的图片 这是图1 这是图2

662
00:51:08,314 --> 00:51:11,174
全图的话 这是图1 这是图2

663
00:51:11,196 --> 00:51:12,446
这是总图

664
00:51:13,089 --> 00:51:15,219
但是即使是看单张图

665
00:51:15,407 --> 00:51:17,637
如果仔细看的话

666
00:51:18,067 --> 00:51:19,667
如果看单个tile的话

667
00:51:20,062 --> 00:51:25,162
4*8的tile中并不止4种颜色

668
00:51:25,405 --> 00:51:27,735
比如这个例子中就有6种颜色

669
00:51:28,789 --> 00:51:32,319
方法就是 两个颜色是来自屏幕内存的

670
00:51:32,359 --> 00:51:34,989
屏幕内存你是可以随时修改的

671
00:51:36,057 --> 00:51:40,057
但是得有坏线的时候VIC才会重新读取屏幕内存·

672
00:51:40,057 --> 00:51:45,287
于是为此创造了一些新的坏线 基本上整个屏幕都是坏线了

673
00:51:45,511 --> 00:51:50,631
所以实际上情况是这样的 也就并不是4个颜色的限制

674
00:51:50,631 --> 00:51:54,631
在每个4x1的方格中可以自由选择颜色

675
00:51:54,928 --> 00:51:56,918
当然也是有一定限制的

676
00:51:57,068 --> 00:51:59,938
这个技巧叫FLI

677
00:52:00,815 --> 00:52:03,285
但是还有更多的技巧

678
00:52:04,289 --> 00:52:06,809
使用了大量的边框区域

679
00:52:07,043 --> 00:52:10,013
如果你看完整的图像的话

680
00:52:10,243 --> 00:52:11,043
下边界

681
00:52:11,312 --> 00:52:13,142
我们已经知道了是HyperScreen

682
00:52:13,442 --> 00:52:15,312
有大量X轴扩展的精灵

683
00:52:15,312 --> 00:52:17,533
可以发现下面的分辨率比较低

684
00:52:17,892 --> 00:52:18,992
但是也不是那么明显

685
00:52:19,276 --> 00:52:22,336
左边和右边也有精灵

686
00:52:22,533 --> 00:52:25,113
这个也是用同样的方法实现的

687
00:52:25,216 --> 00:52:27,116
用横向的屏幕尺寸调节

688
00:52:27,200 --> 00:52:29,290
但是这个就必须要精确到周期

689
00:52:29,395 --> 00:52:34,785
因为屏幕左右切换只是一个字符的差别

690
00:52:35,012 --> 00:52:39,352
就必须要精确计时 而且每行都得这样

691
00:52:40,832 --> 00:52:42,222
这些也是精灵

692
00:52:42,476 --> 00:52:45,066
在最上面也是再放几个精灵

693
00:52:47,928 --> 00:52:50,698
另外一个方法 就是如果在屏幕一行的中间弄一个坏线

694
00:52:50,825 --> 00:52:55,605
那么就会直接开始下一行的读取

695
00:52:55,699 --> 00:52:57,889
这样就可以移动屏幕了

696
00:52:58,786 --> 00:53:00,646
而且一样不需要复制任何东西

697
00:53:01,174 --> 00:53:03,044
所以如果是一般的软件卷动算法

698
00:53:03,163 --> 00:53:06,853
肯定得先手动卷动前八个像素 然后复制整个屏幕

699
00:53:06,957 --> 00:53:08,417
对于文字模式来说没什么问题

700
00:53:08,505 --> 00:53:10,365
但是对于图形模式来说就没有足够的时间了

701
00:53:10,546 --> 00:53:13,876
只是复制数据就需要2-3帧的时间

702
00:53:14,833 --> 00:53:18,833
所以就可以用这种移动方法

703
00:53:18,877 --> 00:53:21,027
这个技巧叫做VSP 可变屏幕位置

704
00:53:21,765 --> 00:53:24,225
之前例子中的monster land就用了这个

705
00:53:24,291 --> 00:53:27,671
运行于多色图形模式下

706
00:53:27,856 --> 00:53:33,986
就是横向移动 然后复制新的数据

707
00:53:36,959 --> 00:53:39,599
另外一个技巧呢，是可以压缩一行

708
00:53:39,981 --> 00:53:41,611
这个技巧叫做Line Crunching（行挤压）

709
00:53:41,807 --> 00:53:48,217
方法是一行没有完成的情况下就触发坏行开始下一行的绘图

710
00:53:48,270 --> 00:53:52,270
如果你1行进行25次这样的操作的话

711
00:53:52,270 --> 00:53:54,860
就可以把整个屏幕压缩到25行中

712
00:53:55,187 --> 00:54:00,587
这样也就可以把屏幕内容向下移动

713
00:54:01,338 --> 00:54:05,918
问题是屏幕上会有很多无用的东西

714
00:54:06,235 --> 00:54:09,315
但是如果你打开多色模式和扩展背景色

715
00:54:09,326 --> 00:54:12,876
VIC就会一直在东西上面显示黑色像素

716
00:54:13,197 --> 00:54:18,427
这样就看不见上面的无用内容了

717
00:54:18,427 --> 00:54:21,957
不过你可以在上面放点精灵 来挡住黑条

718
00:54:22,301 --> 00:54:25,041
如果在游戏中使用那么情况大致就是这样的

719
00:54:25,095 --> 00:54:26,005
这个游戏是Fred's Back

720
00:54:26,100 --> 00:54:27,160
上面就有精灵

721
00:54:27,470 --> 00:54:30,640
下面是真正的图形

722
00:54:30,744 --> 00:54:34,254
而且可以任意移动

723
00:54:34,338 --> 00:54:36,668
这个技巧叫AGSP 任意屏幕位置

724
00:54:41,423 --> 00:54:44,723
正常情况下来说 如果你需要精确周期计时

725
00:54:44,845 --> 00:54:49,845
比如这个例子中我想改变屏幕背景颜色再改回来

726
00:54:50,363 --> 00:54:51,933
会稍微闪烁一下

727
00:54:52,030 --> 00:54:58,480
原因是 如果有中断发生了 那么就必须要完成当前的指令

728
00:54:58,719 --> 00:55:02,719
也就是可能需要不同的周期数

729
00:55:03,222 --> 00:55:07,222
有一个可以缓解这个问题的方法

730
00:55:07,675 --> 00:55:09,345
现在光栅中断触发了

731
00:55:09,433 --> 00:55:11,403
我把光栅中断设置到下一行

732
00:55:12,755 --> 00:55:15,075
设置成另外一个不同的中断服务程序

733
00:55:15,502 --> 00:55:19,042
清除当前的中断标志位 这样可以发生新的中断

734
00:55:19,154 --> 00:55:20,314
之后稍微进行几个NOP

735
00:55:20,542 --> 00:55:22,292
然后中断就会触发

736
00:55:23,489 --> 00:55:26,989
因为触发中断时是一个NOP

737
00:55:27,049 --> 00:55:28,849
所以我知道NOP是两个周期

738
00:55:29,142 --> 00:55:31,262
要么是第一个周期 要么是第二个周期

739
00:55:31,443 --> 00:55:33,223
所以误差就很小

740
00:55:33,561 --> 00:55:35,691
最多1个周期的偏差

741
00:55:36,139 --> 00:55:41,009
但是在下一个中断里 我还是用了很多NOP这样等到一行的最后

742
00:55:42,055 --> 00:55:44,165
然后载入光栅寄存器

743
00:55:44,339 --> 00:55:46,349
对比一下估计的位置

744
00:55:46,552 --> 00:55:49,692
如果一样 就跳转到下一条指令

745
00:55:50,058 --> 00:55:52,928
区别就是 如果分支被触发了

746
00:55:52,928 --> 00:55:53,928
需要3个周期

747
00:55:53,928 --> 00:55:55,578
如果没有 那就是2个周期

748
00:55:55,750 --> 00:56:06,430
这样也就补偿掉了之前不确定的那个周期

749
00:56:06,555 --> 00:56:09,015
比如这个例子 （技巧叫Raster Smoothing）

750
00:56:09,964 --> 00:56:12,094
现在这些芯片我们都看过一遍了

751
00:56:12,488 --> 00:56:22,468
有CPU CIA SID VIC RAM ROM还有PLA

752
00:56:22,676 --> 00:56:26,676
PLA就是那个管理内存布局的

753
00:56:26,881 --> 00:56:30,211
正常情况下就是这样

754
00:56:30,211 --> 00:56:36,683
你可以关闭BASIC ROM、内核ROM、两个都关了

755
00:56:36,683 --> 00:56:39,583
或者全关了

756
00:56:40,233 --> 00:56:43,043
如果卡带槽有额外的ROM

757
00:56:43,086 --> 00:56:45,676
也可以关闭

758
00:56:45,676 --> 00:56:50,316
可以选择用高位ROM取代BASIC的位置

759
00:56:50,316 --> 00:56:51,656
或者都开启

760
00:56:51,851 --> 00:56:53,851
还有一个ULTIMAX模式

761
00:56:53,851 --> 00:56:58,041
这个是个基于C64的游戏平台 只在日本发售

762
00:56:58,041 --> 00:56:59,091
目前已经非常稀有了

763
00:56:59,091 --> 00:57:00,371
因为卖得并不好

764
00:57:00,371 --> 00:57:03,111
只有少于4KB的内存

765
00:57:03,111 --> 00:57:08,591
使用的是ULTIMAX卡带 如果你插入这种卡带

766
00:57:08,591 --> 00:57:10,689
就会使用这种内存映射

767
00:57:12,202 --> 00:57:14,772
磁带接口非常简单明了

768
00:57:14,881 --> 00:57:17,401
只有 感应 马达 读写脚

769
00:57:17,691 --> 00:57:21,691
读写脚直接连上CIA 可以通过寄存器访问到

770
00:57:22,195 --> 00:57:24,515
IEC总线是一个串行总线

771
00:57:24,515 --> 00:57:26,275
可以把驱动器级连起来

772
00:57:26,948 --> 00:57:28,408
有这些引脚

773
00:57:28,408 --> 00:57:30,058
这些是比较有趣的

774
00:57:30,058 --> 00:57:31,818
是数据 时钟 和 Attention

775
00:57:32,280 --> 00:57:34,000
总线协议如图

776
00:57:35,668 --> 00:57:38,948
具体不讲了，大致来说

777
00:57:38,948 --> 00:57:40,878
C64首先拉高ATN脚

778
00:57:40,878 --> 00:57:41,928
然后发送命令

779
00:57:41,928 --> 00:57:43,978
其中包括了驱动器号

780
00:57:44,348 --> 00:57:48,348
使用LISTEN UNLISTEN TALK UNTALK来控制总线

781
00:57:49,423 --> 00:57:50,443
因为总线速度实在是太慢了

782
00:57:50,443 --> 00:57:54,923
最初是由VIC20的1541软驱中的一个芯片bug造成的

783
00:57:55,303 --> 00:57:57,563
协议必须使用软件完成

784
00:57:57,604 --> 00:57:58,774
因为速度实在太慢了

785
00:57:58,774 --> 00:58:01,424
所以就有第三方的这种软件

786
00:58:01,527 --> 00:58:03,367
使用了另外的总线协议

787
00:58:03,663 --> 00:58:05,903
比如说EPYX FastLoad卡带

788
00:58:05,970 --> 00:58:08,310
最高可以快20倍

789
00:58:09,180 --> 00:58:13,620
1541是C64上主要使用的软驱

790
00:58:14,310 --> 00:58:15,930
当然也有后续的版本

791
00:58:15,997 --> 00:58:18,947
使用5.25英寸单面DD软盘

792
00:58:19,145 --> 00:58:21,905
40个磁道中一共用了35个磁道

793
00:58:22,624 --> 00:58:25,494
不同的磁道有的不同的扇区数

794
00:58:25,733 --> 00:58:30,273
最后一共有683个块

795
00:58:30,356 --> 00:58:32,886
也就是大约一共170.75KB

796
00:58:34,086 --> 00:58:36,016
磁道是这样的

797
00:58:36,300 --> 00:58:38,060
没有使用索引孔

798
00:58:38,150 --> 00:58:39,240
有一个同步记号

799
00:58:39,268 --> 00:58:40,338
使用的全部是1

800
00:58:40,382 --> 00:58:43,442
所以剩余的数据就需要编码

801
00:58:43,468 --> 00:58:45,898
以保证不会出现全是1的情况

802
00:58:45,953 --> 00:58:49,343
这个是扇区的头部

803
00:58:49,443 --> 00:58:50,543
另外一个同步记号

804
00:58:50,642 --> 00:58:52,272
然后是真正的扇区数据

805
00:58:52,365 --> 00:58:53,535
当然是GCR编码过的

806
00:58:53,722 --> 00:58:55,082
之后再接一个同步记号

807
00:58:56,524 --> 00:58:58,344
目录格式是这样的

808
00:58:58,508 --> 00:58:59,758
文件系统是这样的

809
00:58:59,828 --> 00:59:02,598
一个区块可用性表

810
00:59:02,733 --> 00:59:04,303
磁盘名称是16个字符

811
00:59:04,556 --> 00:59:10,856
另外在磁道18上是所有的文件名 也都是16个字符

812
00:59:10,955 --> 00:59:11,975
设计算是相当现代的

813
00:59:12,700 --> 00:59:15,450
驱动机械大致就是这样的

814
00:59:15,545 --> 00:59:17,035
这是逻辑板

815
00:59:17,197 --> 00:59:19,437
完全是一个独立的6502电脑

816
00:59:20,813 --> 00:59:22,523
两个VIA控制器

817
00:59:23,294 --> 00:59:26,704
还有ROM RAM 还有一个PLA

818
00:59:27,220 --> 00:59:28,010
内存映射是这样的

819
00:59:28,117 --> 00:59:29,737
有4KB的内存

820
00:59:30,072 --> 00:59:34,162
IO区域 也就是两个VIA

821
00:59:34,162 --> 00:59:35,382
还有ROM

822
00:59:35,877 --> 00:59:39,877
有趣的是老的Commodore软驱有两个CPU

823
00:59:39,877 --> 00:59:41,727
一个负责总线和文件系统

824
00:59:41,727 --> 00:59:44,277
另外一个负责电机、磁头驱动一类的

825
00:59:44,307 --> 00:59:48,657
而在1541上则是只有一个CPU 在两个之间切换

826
00:59:48,657 --> 00:59:51,537
一个返回Job Codes 一个返回Error Codes

827
00:59:52,290 --> 00:59:54,270
另外还有双面版本

828
00:59:54,324 --> 00:59:59,384
3.5英寸版本 但是因为兼容性原因就没那么流行

829
00:59:59,384 --> 01:00:00,474
甚至于还有硬盘

830
01:00:00,743 --> 01:00:04,743
有内存扩展 Freezer 加速卡

831
01:00:05,198 --> 01:00:10,758
这个是C64的16Bit CPU扩展卡 8MHz主频2MB内存

832
01:00:10,849 --> 01:00:15,379
甚至于还有SuperCPU 可以到20MHz 16MB内存

833
01:00:15,739 --> 01:00:19,739
对于GEOS和支持的游戏来说还是很不错的

834
01:00:20,084 --> 01:00:21,384
这些就很晚才有了

835
01:00:21,384 --> 01:00:22,994
这个是C64 GTV

836
01:00:23,067 --> 01:00:27,757
是一个C64 FPGA实现 (应该是ASIC吧……)

837
01:00:28,184 --> 01:00:31,494
可扩展性也很强 可以自己接IEC、键盘什么的上去

838
01:00:33,331 --> 01:00:35,981
所以接下来……

839
01:00:36,378 --> 01:00:37,628
有没有学到什么新的东西呢

840
01:00:37,628 --> 01:00:39,798
如果有 请去写个demo

841
01:00:49,803 --> 01:00:52,973
如果没有 但是如果你了解其它的系统

842
01:00:52,973 --> 01:00:55,993
请给其它的系统也做个演讲

843
01:00:55,993 --> 01:01:01,273
我对他们的内部非常感兴趣

844
01:01:01,588 --> 01:01:03,148
谢谢
